// PROJECT
System waste_service

// MESSAGES AND EVENTS ========================================================
// SmartDevice (truck) -> TypesProvider
Request typesrequest:	typesrequest(_)
// TypesProvider -> SmartDevice
Reply typesreply:		typesreply(TYPES)

// SmartDevice (truck) -> WasteService
Request storerequest:	storerequest(TYPE, LOAD)
// WasteService -> SmartDevice
Reply loadaccepted:		loadaccepted(_)
Reply loadrejected:		loadrejected(_)

// WasteService -> TransportTrolley
Request deposit:			deposit(TYPE, LOAD)
// TransportTrolley -> WasteService
Reply pickupcompleted:		pickupcompleted(_)
// TransportTrolley -> WasteService
Dispatch depositcompleted:	depositcompleted(_)
Dispatch depositfailed:		depositfailed(REASON)

// TrolleyStateProvider
Dispatch updatetrolleystate:		updatetrolleystate(STATE) // TO-DO: use COAP update
Request requesttrolleystate:		requesttrolleystate(_)
Request requesttrolleyprevstate:	requesttrolleyprevstate(_)

Reply state_home:		state_home(_)
Reply state_toindoor:	state_toindoor(_)
Reply state_pickup:		state_pickup(_)
Reply state_tobox:		state_tobox(_)
Reply state_dump:		state_dump(_)
Reply state_tohome:		state_tohome(_)
Reply state_stopped:	state_stopped(_)

// Basicrobot
Dispatch cmd:		cmd(MOVE)
Dispatch end:		end(ARG)  
Request step:		step(TIME)
Reply stepdone:		stepdone(V)
Reply stepfail:		stepfail(V)
Event alarm:		alarm(X)
Event sonar:		sonar( DISTANCE )
Dispatch obstacle:	obstacle( ARG ) 	//generated by distancefilter
Event info:			info( ARG ) 	    //for external components, not coap-observed

// PathExecutor
Request	dopath:		dopath( PATH, OWNER )
Reply dopathdone:	dopathdone( ARG )
Reply dopathfail:	dopathfail( ARG )
Dispatch pathdone:	pathdone( P )
Dispatch pathfail:	pathdone( P )
Dispatch cmd:		cmd(MOVE)
Request step:		step( TIME )
Reply stepdone:		stepdone(V)
Reply stepfail:		stepfail(DURATION, CAUSE)
Event alarm:		alarm(X)

// Sprint2 Problem Analysis
// Sonar -> AlarmController
Dispatch sonar_data:	sonar_data(DISTANCE)
// AlarmController -> System
Event startAlarm:		startAlarm(_)
// AlarmController -> System
Event stopAlarm:		stopAlarm(_)

Reply stop:				stop(_)
Dispatch resume:		resume(_)

// CONTEXES ===================================================================
//Context ctx_smartdevice 		ip [host="localhost" port=11799]
Context ctx_wasteservice		ip [host="localhost" port=11800]
Context ctx_transporttrolley	ip [host="localhost" port=11801]
Context ctx_raspberry			ip [host="localhost" port=11802]
Context ctx_robot				ip [host="localhost" port=8020]

// ACTORS =====================================================================
/*QActor smartdevice_simulator context ctx_smartdevice {
	[#
		var Types: String = ""
		var TypesList = arrayListOf<wasteservice.WasteType>()
		
		var WasteType: wasteservice.WasteType = wasteservice.WasteType.PLASTIC
		var WasteWeight: Double = 10.0
	#]
	State state_init initial {
		println("[SmartDevice Simulator] Started")
		discardMsg Off
	}
	Goto state_typesrequest
	
	State state_typesrequest {
		delay 1000
		request typesprovider -m typesrequest : typesrequest(_)
		println("[SmartDevice Simulator] Sent typesrequest()")
	}
	Transition t1 whenReply	typesreply -> state_handle_types
	
	State state_handle_types {
		printCurrentMessage
		onMsg(typesreply : typesreply(TYPES)) {
			[#
				Types = payloadArg(0).toString()
				TypesList = wasteservice.Utils.getWasteTypesList(Types, "_")
			#]
		}
		println("[SmartDevice Simulator] Types list: $TypesList")
	}
	Goto state_storerequest
	
	State state_storerequest {
		[#
			WasteType = wasteservice.WasteType.values()[kotlin.random.Random.nextInt(0, TypesList.size)]
		#]
		delay 1000
		request wasteservice -m storerequest : storerequest($WasteType, $WasteWeight)
		println("[SmartDevice Simulator] Sent storerequest($WasteType, $WasteWeight)")
	}
	Transition t2	whenReply	loadaccepted -> state_handle_loadaccepted
					whenReply	loadrejected -> state_handle_loadrejected
	
	State state_handle_loadaccepted {
		println("[SmartDevice Simulator] Received LoadAccepted")
	}
	Goto state_storerequest
	
	State state_handle_loadrejected {
		println("[SmartDevice Simulator] Received LoadRejected")
	}
	Goto state_storerequest
}*/

// Actor that provides the types of waste that can be stored
// in the waste service area, when a Smart Device connects
QActor typesprovider context ctx_wasteservice {
	[#
		var WasteTypes: String = wasteservice.Utils.getWasteTypesString("_")
	#]
	State state_init initial {
		println("[TypesProvider] Started. WasteTypes: $WasteTypes")
		discardMsg Off
	}
	Goto state_idle
	
	State state_idle {
		println("[TypesProvider] Waiting for type requests...")
	}
	Transition t0	whenRequest typesrequest	-> state_handle_wastetypes_request
	
	State state_handle_wastetypes_request {
		printCurrentMessage
		replyTo typesrequest with typesreply	: typesreply($WasteTypes)
		println("[TypesProvider] Replied with types list: $WasteTypes")
	}
	Goto state_idle
}

QActor wasteservice context ctx_wasteservice {
	[#
		var RequestedWasteType: wasteservice.WasteType = wasteservice.WasteType.values()[0]
		var RequestedWasteWeight: Double = 1.0
		
		val WasteService = wasteservice.WasteService()
		
		var WaitingPickup: Boolean = false
		var WaitingDeposit: Boolean = false
	#]
	State state_init initial {
		println("[WasteService] Started.")
		println("[WasteService] Current storage:")
		[# WasteService.printFancyStatusString() #]
		discardMsg Off
	}
	Goto state_idle
	
	State state_idle {
		println("[WasteService] Waiting for store requests...")
	}
	Transition t0	whenRequest storerequest	-> state_handle_storerequest

	State state_handle_storerequest {
		printCurrentMessage
		onMsg(storerequest : storerequest(TYPE, LOAD)) {
			[#
				var Type = payloadArg(0)
				var Load = payloadArg(1)
			#]
			println("[WasteService] Received storerequest($Type, $Load)")
			
			if [# wasteservice.Utils.isValidWasteType(Type) &&
					wasteservice.Utils.isValidWasteWeight(Load) #]
			{
				[#
					RequestedWasteType = wasteservice.WasteType.valueOf(Type)
					RequestedWasteWeight = payloadArg(1).toDouble()
				#]
				
				if [# WasteService.canPreStore(RequestedWasteType, RequestedWasteWeight) #]
				{
					// Update the pre-storage counter
					[#
						WasteService.addToPreStorage(RequestedWasteType, RequestedWasteWeight)
					
						WaitingPickup = true
					#]
					println("[WasteService] There is enough space.")
					request transporttrolley -m deposit : deposit( $RequestedWasteType, $RequestedWasteWeight )
				}
				else
				{
					[# WaitingPickup = false #]
					
					[# wasteservice.Utils.printFail("[WasteService] Load rejected: there is not enough space in the container to store the load.") #]
					replyTo storerequest with loadrejected: loadrejected(_)
				}
			}
			else
			{
				[# WaitingPickup = false #]
				
				[# wasteservice.Utils.printFail("[WasteService] Load rejected: one or more parameters are invalid.") #]
				replyTo storerequest with loadrejected: loadrejected(_)
			}
			
			println("[WasteService] Current storage:")
			[# WasteService.printFancyStatusString() #]
		}
	}
	Goto state_idle if [# WaitingPickup == false #] else state_waiting_pickup
	
	State state_waiting_pickup {
		println("[WasteService] Waiting for pickup completion...")
	}
	Transition t1 whenReply pickupcompleted	-> state_pickup_completed
	
	State state_pickup_completed {
		[#
			WaitingPickup = false
			WaitingDeposit = true
		#]
		
		[# wasteservice.Utils.printCorrect("[WasteService] Pickup completed, sent Load Accepted.") #]
		replyTo storerequest with loadaccepted: loadaccepted(_)
	}
	Goto state_waiting_deposit
	
	State state_waiting_deposit {
		println("[WasteService] Waiting for deposit completion...")
	}
	Transition t2	whenMsg depositcompleted	-> state_deposit_completed
					whenMsg depositfailed		-> state_deposit_failed
	
	State state_deposit_completed {
		// Update the actual storage counter
		[#
			WasteService.addToStorage(RequestedWasteType, RequestedWasteWeight)
			
			WaitingDeposit = false
		#]
		println("[WasteService] Deposit completed. Current storage:")
		[# WasteService.printFancyStatusString() #]
	}
	Goto state_idle
	
	State state_deposit_failed {
		onMsg(depositfailed : depositfailed(REASON)) {
			// Reset the pre storage counter
			[#
				// Reset PreStorage
				
				WaitingDeposit = false
				var Error = payloadArg(0)
			#]
			println("[WasteService] Deposit failed: $Error.")
		}
		println("[WasteService] Current storage:")
		[# WasteService.printFancyStatusString() #]
	}
	Goto state_idle
}

QActor transporttrolley context ctx_transporttrolley {
	[# 
		var Actions: String = "" 
		var Progress = ""
		
		var WasteType: wasteservice.WasteType = wasteservice.WasteType.PLASTIC
		var WasteLoad: Double = 0.0
	#]
	State state_init initial {
		[#
			plannerBCR.initAI()
			plannerBCR.loadRoomMap("mapRoomEmpty")
			plannerBCR.showMap()
			plannerBCR.loadMapConfig("mapConfigWasteService")
			println("MapConfig:")
			plannerBCR.showFancyMapConfig()
		#]
		println("[TransportTrolley] Started.")
	}
	Goto state_idle
	
	State state_idle {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(HOME) // TO-DO: test/check
		println("[TransportTrolley] Waiting for deposit requests...")
	}
	Transition t0	whenRequest deposit		-> state_handle_deposit_request
	
	State state_handle_deposit_request {
		printCurrentMessage
		onMsg(deposit: deposit(TYPE, LOAD)) {
			[#
				WasteType = wasteservice.WasteType.valueOf(payloadArg(0))
				WasteLoad = payloadArg(1).toDouble()
			#]
			println("[TransportTrolley] Deposit request received.")
		}
	}
	Goto state_move_to_indoor
	
	State state_move_to_indoor {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(TO_INDOOR) // TO-DO: test/check
		
		println("[TransportTrolley] Moving to INDOOR...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = plannerBCR.getNearestPositionToCellType(curPos, "INDOOR")
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
	}
	Transition t1	whenReply dopathdone	-> state_pickup
					whenReply dopathfail	-> state_error
					//whenReply stop			-> state_stop
	
	State state_pickup {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(PICKUP) // TO-DO: test/check
		
		println("[TransportTrolley] Picking up the load of $WasteType...")
		[# wasteservice.Utils.simulateAction(WasteLoad) #]
		println("[TransportTrolley] Pickup completed.")
		
		replyTo deposit with pickupcompleted: pickupcompleted(_)
	}
	Goto state_move_to_box
	
	State state_move_to_box {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(TO_BOX) // TO-DO: test/check
		
		println("[TransportTrolley] Moving to ${WasteType.name}_BOX...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = plannerBCR.getNearestPositionToCellType(curPos, WasteType.name)
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
	}
	Transition t2	whenReply dopathdone	-> state_dump
					whenReply dopathfail	-> state_error
					//whenReply stop			-> state_stop
	
	State state_dump {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(DUMP) // TO-DO: test/check
		
		println("[TransportTrolley] Dumping the load...")
		[# wasteservice.Utils.simulateAction(WasteLoad) #]
		
		println("[TransportTrolley] Dump completed.")
		
		forward wasteservice -m depositcompleted : depositcompleted(_)
	}
	Goto state_move_to_home
	
	State state_move_to_home {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(TO_HOME) // TO-DO: test/check
		
		println("[TransportTrolley] Moving to HOME...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = plannerBCR.getNearestPositionToCellType(curPos, "HOME")
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
		
		// TO-DO (Sprint2): Stop returning HOME in case a new request arrives
	}
	Transition t3	whenReply dopathdone	-> state_idle
					whenReply dopathfail	-> state_error
					//whenReply stop			-> state_stop

	State state_stop {
		forward trolleystateprovider -m updatetrolleystate : updatetrolleystate(STOPPED) // TO-DO: test/check
		
		println("[TransportTrolley] Waiting for the alarm to stop...")
	}
	Transition t4 whenEvent stopAlarm -> state_resume
	
	State state_resume {
		// Do the remaining path
		println("[TransportTrolley] Resuming activity...")
		
		// send resume to unlock pathexecutor
		forward pathexecutor -m resume: resume(_)
		
		// send request to trolleystate provider
		request trolleystateprovider -m requesttrolleyprevstate: requesttrolleyprevstate(_)
		// TO-DO: test/check
	}
	Transition t5	whenReply state_home		-> state_idle
					whenReply state_toindoor	-> state_move_to_indoor
					whenReply state_pickup		-> state_move_to_box
					whenReply state_tobox		-> state_move_to_box
					whenReply state_dump		-> state_move_to_home
					whenReply state_tohome		-> state_move_to_home
					// TO-DO: test/check
	
	State state_error {
		onMsg(dopathfail: dopathfail(PATH_STILL_TO_DO)) {
			[#
				var PathStillToDo = payloadArg(0)
			#]
			println("[TransportTrolley] An Error occurred while trying to move along a path.")
			println("[TransportTrolley] Path still to do: $PathStillToDo")
			
			// TO-DO: Return to HOME?
		}
	}
	Goto state_idle
}

QActor trolleystateprovider context ctx_transporttrolley {
	[#
		var PrevState: wasteservice.TransportTrolleyState = wasteservice.TransportTrolleyState.values()[0]
		var State: wasteservice.TransportTrolleyState = wasteservice.TransportTrolleyState.values()[0]
	#]
	State state_init initial {
		println("[TrolleyStateProvider] Started.")
	}
	Goto state_idle
	
	State state_idle {
		println("[TrolleyStateProvider] Idle...")
	}
	// oncoap update
	Transition t0	whenMsg updatetrolleystate			-> state_update_trolley_state
					whenRequest requesttrolleyprevstate	-> state_handle_prev_state_request
					whenRequest requesttrolleystate		-> state_handle_state_request
					
	State state_update_trolley_state {
		onMsg (updatetrolleystate: updatetrolleystate(STATE)){
			[# 
				PrevState = State
				State = wasteservice.TransportTrolleyState.valueOf(payloadArg(0))
			#]
			println("[TrolleyStateProvider] State updated. Prev: $PrevState, State: $State")
		}
	}
	Goto state_idle
	
	State state_handle_state_request {
		// TO-DO
	}
	Goto state_idle
	
	// TO-DO: test/check
	State state_handle_prev_state_request {
		println("[TrolleyStateProvider] Received prev state request, replied with: $PrevState")
		if [# State == wasteservice.TransportTrolleyState.HOME #] {
			replyTo requesttrolleyprevstate with state_home: state_home(_)
		}
		if [# State == wasteservice.TransportTrolleyState.TO_INDOOR #] {
			replyTo requesttrolleyprevstate with state_toindoor: state_toindoor(_)
		}
		if [# State == wasteservice.TransportTrolleyState.PICKUP #] {
			replyTo requesttrolleyprevstate with state_pickup: state_pickup(_)
		}
		if [# State == wasteservice.TransportTrolleyState.TO_BOX #] {
			replyTo requesttrolleyprevstate with state_tobox: state_tobox(_)
		}
		if [# State == wasteservice.TransportTrolleyState.DUMP #] {
			replyTo requesttrolleyprevstate with state_dump: state_dump(_)
		}
		if [# State == wasteservice.TransportTrolleyState.TO_HOME #] {
			replyTo requesttrolleyprevstate with state_tohome: state_tohome(_)
		}
		if [# State == wasteservice.TransportTrolleyState.STOPPED #] {
			replyTo requesttrolleyprevstate with state_stopped: state_stopped(_)
		}
	}
	Goto state_idle
}

QActor pathexecutor context ctx_transporttrolley {
	[# 
		var CurMoveTodo = ""
		var MovesDone = ""
		var TotPathMoves = 0
	#]
	
	State state_init initial {
		println("[PathExecutor] Started.")
	}
	Goto state_idle
	
	State state_idle {
		[# CurMoveTodo = "" #]
		[# sysUtil.logMsgs=true #]
		println("[PathExecutor] Waiting for a path...")
	}
	Transition t0	whenRequest dopath		-> state_do_path
					whenEvent startAlarm	-> state_handle_alarm
	
	State state_do_path {
		printCurrentMessage
		onMsg(dopath: dopath(P, C)) {
			[# 
				val path = payloadArg(0)
				pathut.setPath(path)
				TotPathMoves = pathut.getPathTodo().length
			#]
			println("$path")
		}
		
		println("[PathExecutor] Path to do: ${pathut.getPathTodo()}")
	}
	Goto state_next_move
	
	State state_next_move {
		[# CurMoveTodo = pathut.nextMove() #]
		[# MovesDone += CurMoveTodo #]
		println("[PathExecutor] Current move to do: $CurMoveTodo")
	}
	Goto state_end_work_ok if [# CurMoveTodo.length == 0 #] else state_do_move
	
	State state_do_move {
		[#
			plannerBCR.updateMap(CurMoveTodo, "")
			// plannerBCR.showMap()
			// plannerBCR.showCurrentRobotState()	
		#]
		delay 50
	}
	Goto state_do_move_forward if [# CurMoveTodo == "w" #] else state_do_move_turn
	
	State state_do_move_forward {
		request basicrobot -m step: step(350)
	}
	Transition t1	whenEvent startAlarm	-> state_handle_alarm
					whenReply stepdone		-> state_next_move
					whenReply stepfail		-> state_end_work_fail
	
	State state_do_move_turn {
		forward basicrobot -m cmd: cmd($CurMoveTodo)
	}
	Transition t2	whenTime 350			-> state_next_move
					whenEvent startAlarm	-> state_handle_alarm
	
	State state_end_work_ok {
		println("[PathExecutor] Path done.")
		replyTo dopath with dopathdone: dopathdone( ok )
	}
	Goto state_idle
	
	State state_end_work_fail {
		[# var PathStillTodo = pathut.getPathTodo() #]
		println("[PathExecutor] Path failure. Path still to do: $PathStillTodo")
		replyTo dopath with dopathfail: dopathfail( $PathStillTodo )
		
		println("[PathExecutor] Out of service.")
		// NB: no more transitions since the WasteService is no longer operative
		// this state could be caused by an out of sync between the PathExec position and
		// the actual Robot position -> better to terminate the application
		
		terminate 1
	}
	//Transition t0 whenEvent alarm -> handleAlarm
	
	State state_handle_alarm {
		[# var PathTodo = pathut.getPathTodo() #]
		println("[PathExecutor] Alarm detected, trolley stopped. Path to do: $PathTodo")
	}
	Transition t3 whenEvent stopAlarm -> state_resume
	
	State state_resume {
		println("[PathExecutor] Alarm retracted. Resuming...")
	}
	Goto state_next_move if [# MovesDone.length != TotPathMoves #] else state_idle
}

QActor basicrobot context ctx_robot {
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
 		//[# unibo.comm22.utils.CommSystemConfig.tracing = false #]  //tracing at unibo.comm22 level
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021
 
  		//run unibo.robot.robotSupport.move( "a" )    //synch
 		//run unibo.robot.robotSupport.move( "d" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			 
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
  			[# CurrentMove = payloadArg(0) #]
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "moveactivated(${payloadArg(0)})" #]
		}
	 }
	 Goto work   
	 
	State handleObstacle{
		//println("basicrobotttttttttt | handleObstacle ${CurrentMove}")	
		//run unibo.robot.robotSupport.move( "h" ) //non importa 
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		//JUNE22: behavior embedded in VirtualrobotSupport2021
		 
		//if[# CurrentMove == "w" #]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	
		//	run unibo.robot.robotSupport.move( "s" )
		//	delay 100 
		//	run unibo.robot.robotSupport.move( "h" ) 
 		//}
 		//emit info : info( obstacledoing(w) )
	}
	Goto work  
 
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0
		whenTimeVar StepTime  -> stepDone  	 
 		whenMsg  obstacle     -> stepFail		
    	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  

	State stepFail{  	 	
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		//[# var TunedDuration =  Duration * 5 / 6 #]
		//[# var TunedDuration   = kotlin.math.round( (StepTime - Duration) * 15 / 100 ) #]
		[# var TunedDuration   =  ((StepTime - Duration) * 15 / 100).toLong()   #]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}
}

// Sprint2 Problem Analysis ===================================================
/*QActor sonar_mock_test context ctx_raspberry {
	State state_init initial {
		println("[SonarMockTest] Started.")
		
		delay 10000
	}
	Goto state_detect
	
	State state_detect {
		[# var Distance = kotlin.random.Random.nextInt(0, 100) #]
		println("[SonarMockTest] Sending distance: $Distance")
		
		// send distance
		forward alarm_controller -m sonar_data: sonar_data($Distance)
		
		delay 7000
	}
	Goto state_detect
}*/

QActor alarm_controller context ctx_raspberry {
	[#
		var SonarDistance: Double = Double.MAX_VALUE
		var PrevAlarm: Boolean = false
		var Alarm: Boolean = false
	#]
	State state_init initial {
		println("[AlarmController] Started.")
	}
	Goto state_idle
	
	State state_idle {
		println("[AlarmController] Listening for sonar data...")
		println("[AlarmController] Current state: $Alarm")
		[# PrevAlarm = Alarm #]
	}
	Transition t0 whenMsg sonar_data -> state_handle_sonar_data
	
	State state_handle_sonar_data {
		printCurrentMessage
		
		onMsg(sonar_data: sonar_data(DISTANCE)) {
			[# Alarm = wasteservice.Utils.isAlarm(payloadArg(0)) #]
	    	println("[AlarmController] Received sonar data: ${payloadArg(0)}")
	    	
	    	// Check if state changed
	    	if [# Alarm != PrevAlarm #] {
	    		if [# Alarm == true #] {
	    			println("[AlarmController] Alarm situation!")
	    	
	    			emit startAlarm : startAlarm(_)
	    		} else {
	    			println("[AlarmController] Alarm over.")
	    			
	    			emit stopAlarm : stopAlarm(_)
	    		}
	    	}
	    }
	}
	Goto state_idle
}