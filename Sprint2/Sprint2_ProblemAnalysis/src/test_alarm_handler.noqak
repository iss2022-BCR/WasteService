System test_alarm_handler

// WasteService -> TransportTrolley
Request deposit		:	deposit(TYPE)
// TransportTrolley -> WasteService
Reply pickupcompleted	: pickupcompleted(_)
// TransportTrolley -> WasteService
Dispatch depositcompleted	:	depositcompleted(_)
Dispatch depositfailed		:	depositfailed(REASON)

// Sonar
Event		sonarevent :	sonarevent(DISTANCE)
Dispatch	stop :			stop(_)
Dispatch	resume : 		resume(_)

Context ctx_alarm_handler_test		ip [host="localhost" port=11800]

// SonarDevice test: simulate a Sonar Device
QActor sonar_device_ah_test context ctx_alarm_handler_test {
	[# var Distance: Double #]
	State init initial {
		println("[SonarDevice] Started.")
	}
	Goto state_idle
	
	State state_idle {
		
	}
	Transition t0 whenTime 1000 -> state_misure_distance
	
	State state_misure_distance {
		if [# kotlin.random.Random.nextBoolean() #] {
			[# Distance = 40.0 #]
		}
		else {
			[# Distance = 80.0 #]
		}
		emit sonarevent : sonarevent($Distance)
	}
	Goto state_idle
}

// Handles sonar events, and notifies the TT only about the state change
QActor alarm_handler context ctx_alarm_handler_test {
	[#
		var SonarDistance: Double = Double.MAX_VALUE
		var PrevAlarm: Boolean = false
		var Alarm: Boolean = false
	#]
	State state_init initial {
		println("[AlarmHandler] Started.")
	}
	Goto state_idle
	
	State state_idle {
		println("[AlarmHandler] Listening for sonar events...")
		[# PrevAlarm = Alarm #]
	}
	Transition t0 whenEvent sonarevent -> state_handle_sonar_event
	
	State state_handle_sonar_event {
		printCurrentMessage
		
		onMsg(sonarevent: sonarevent(DISTANCE)) {
			[# Alarm = wasteservice.Utils.isAlarm( payloadArg(0) ) #]
	    	println("[AlarmHandler] Received sonar event: ${payloadArg(0)}")
	    	
	    	// Check if state changed
	    	if [# Alarm != PrevAlarm #] {
	    		if [# Alarm == true #] {
	    			// Send stop
	    			forward transporttrolley_ah_test -m stop : stop(_)
	    		} else {
	    			// Send resume
	    			forward transporttrolley_ah_test -m resume : resume(_)
	    		}
	    	}
	    }
	}
	Goto state_idle
}

QActor wasteservice_ah_test context ctx_alarm_handler_test {
	
	State state_init initial {
		println("[WasteService] Started.")
	}
	Goto state_idle
	
	State state_idle {
		
	}
	Goto state_deposit
	
	State state_deposit {
		// emulate send deposit request
		
		delay 1000
	}
	Goto state_idle
}

QActor transporttrolley_ah_test context ctx_alarm_handler_test {
	State state_init initial {
		println("[TransportTrolley] Started.")
	}
	Goto state_idle
	
	State state_idle {
		println("[TransportTrolley] Waiting for deposit requests...")
	}
	Transition t1	whenRequest deposit		-> state_handle_deposit_request
	
	State state_handle_deposit_request {
		printCurrentMessage
		onMsg(deposit: deposit(TYPE)) {
			[# WasteType = wasteservice.WasteType.valueOf(payloadArg(0)) #]
			println("[TransportTrolley] Deposit request received.")
		}
	}
	Goto state_move_to_indoor
	
	State state_move_to_indoor {
		println("[TransportTrolley] Moving to INDOOR...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = wasteservice.MapConfigUtils.getNearestPositionToCellType(curPos, "INDOOR")
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
	}
	Transition t1 whenReply dopathdone -> state_pickup
				  whenReply dopathfail -> state_error
	
	State state_pickup {
		println("[TransportTrolley] Picking up the load of $WasteType...")
		delay 3000
		println("[TransportTrolley] Pickup completed.")
		
		replyTo deposit with pickupcompleted: pickupcompleted(_)
	}
	Goto state_move_to_box
	//Goto state_move_to_glassbox if [# WasteType == wasteservice.WasteType.GLASS #] else state_move_to_plasticbox
	
	State state_move_to_box {
		// TO-DO: 1 step alla volta controllando se ci sono nuove deposit request\
		println("[TransportTrolley] Moving to ${WasteType.name}_BOX...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = wasteservice.MapConfigUtils.getNearestPositionToCellType(curPos, WasteType.name)
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
	}
	Transition t1 whenReply dopathdone -> state_dump
				  whenReply dopathfail -> state_error
	
	State state_dump {
		println("[TransportTrolley] Dumping the load...")
		delay 3000
		println("[TransportTrolley] Dump completed.")
		
		forward wasteservice -m depositcompleted : depositcompleted(_)
	}
	Goto state_move_to_home
	
	State state_move_to_home {
		println("[TransportTrolley] Moving to HOME...")
		[#
			val curPos: Pair<Int, Int> = plannerBCR.get_curPos()
			val goal: Pair<Int, Int> = wasteservice.MapConfigUtils.getNearestPositionToCellType(curPos, "HOME")
			plannerBCR.setGoal(goal.first, goal.second)
			plannerBCR.doPlan()
			Actions = plannerBCR.getActionsString()
		#]
		request pathexecutor -m dopath : dopath($Actions, transporttrolley)
	}
	Transition t1 	
					whenReply dopathdone -> state_idle
				  	whenReply dopathfail -> state_error
		
	// one step at a time, check if 		  	
	State state_returning_to_home {
		
	}
	
	State state_error {
		onMsg(dopathfail: dopathfail(PATH_STILL_TO_DO)) {
			[#
				var PathStillToDo = payloadArg(0)
			#]
			println("[TransportTrolley] An Error occurred while trying to move along a path.")
			println("[TransportTrolley] Path still to do: $PathStillToDo")
			
			// TO-DO: Return to HOME
		}
	}
	Goto state_idle
	
	State state_stop {
		
	}
	
	State state_resume {
		
	}
}