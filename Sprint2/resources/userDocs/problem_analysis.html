<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Sprint2</title>
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/code.css">
        <script type="text/javascript" src="../../../commons/resources/scripts/myScripts.js"></script>
    </head>

    <body onload="loadNav();">
        <div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
        <div id="sidenav" class="sidenav">
            <a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
            <a class="sprint" href="../../../Sprint0/index.html">Sprint0</a>
            <a class="sprint" href="../../../Sprint1/index.html">Sprint1</a>
            <a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
            <a href="../../index.html">Index</a>
            <a href="final_theme.html">Final Theme</a>
            <a href="requirement_analysis.html">Requirement<br/>Analysis</a>
            <a class="selected" href="problem_analysis.html">Problem Analysis</a>
            <div class="sidenavSection">
                <a href="#Sprint2-Software">Sprint 2 Software</a>
                <div class="sidenavSubSection">
                    <a href="#Sonar">Sonar</a>
                    <a href="#Stop-Resume">Stop/Resume</a>
                    <a href="#Led">Led</a>
                    <a href="#Extra">Extra</a>
                </div>
                <a href="#Interactions">Interactions</a>
                <div class="sidenavSubSection">
                    <a href="#Messages">New Messages</a>
                </div>
                <a href="#Logical-Architecture">Logical Architecture</a>
                <a href="#Test-Plans">Test Plans</a>
            </div>
            <a href="project.html">Project</a>
            <a href="test_plans.html">Test Plans</a>
            <a href="conclusions.html">Conclusions</a>
            <a href="team.html">Team</a>
            <p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
            <a class="sprint" href="../../../Sprint3/index.html">Sprint3</a>
            <bottom-spacer/>
        </div>

        <div id="main">
            <h1 align="center">Problem Analysis</h1>
            Problematiche che possono verificarsi;
            <br/>
            Vedere quale software è disponibile e dove/come possiamo utilizzarlo;
            <br/>

            il problema principale è realizzare il meccanismo di stop/resume.
            E conseguentemente implementare il return a home.

        <!--
            <h2 id="Defects-Solving">Defects Solving</h2>
            
            <problem><a href="../../../Sprint1/resources/userDocs/conclusions.html#Bugs">Bug #7</a>: LoarRejected Blocked</problem>
            <b>Problem</b>: If a Smart Device sends a store request when the Waste Service is already
            handling a deposit action, the request isn't consumed even if the load cannot be accepted
            (differently from what we've considered in Sprint1 Problem Analysis).
            <br/>
            <b>Consideration</b>: this occurs because the implementation is based on a request/response model:
                the message in the Waste Service queue cannot be consumed because the Waste Service itself is waiting 
                for the Transport Trolley reply, while it's performing a deposit action. That suggests us that
                the request/response model does not suit the interaction needed to meet the requirement that
                "the truck driver must be sent off as soon as possible".
            <solution>
                <b>Solution</b>: use a <ksi>dispatch/dispatch interaction model</ksi> between the Waste Service and the Transport Trolley.
                <br/>
                <b>Reasons</b>: the dispatch/dispatch interaction allows the Waste Service <ksi>not to have to wait</ksi> for a
                reply from the Transport Trolley, which means it can handle other requests in the meantime.
            </solution>
            
            <h3>MapEditor</h3>
        -->
            <h2>Logical Architecture from Sprint1</h2>
            <img width="100%" src="../../../Sprint1/Sprint1_Project/sprint1_waste_service/project_logical_architecture_core-business.png"/>
            QAK model: <a href="../../../Sprint1/Sprint1_Project/sprint1_waste_service/src/waste_service.qak">waste_service.qak</a>

            <h2 id="Sprint2-Software">Sprint 2 Software</h2>
            The Sprint 2 software will be the product of the analysis of problems
            related to the Raspberry Pi.
            We will analyze the main problems of the <b><i>4th requirement</i></b>, and discuss the
            possible solutions and their differences.
            <br/>
            <br/>
            Since the Raspberry Pi is situated on a computational node different from
            the Waste Service one, we will need to add a new context, which we're going
            to call "<ksi>ctx_raspberry</ksi>".
            The actors of this context will be running on the Raspberry Pi device.
            
            <h3 id="Sonar">Sonar</h3>
            What's the purpose of the sonar? Which components depend on it and where will
            them be located?
            <highlight1>The sonar is responsible for the stop/resume functionality.</highlight1>

            <problem>Get input from the component HC-SR04</problem>
            The sonar needs to get the input from the physical component (HC-SR04)

            <br/>
            For the problem analysis test plans we're going to use an actor that simulates
            the sonar input component, in localhost.

            
            <problem>Sonar data sent</problem>
            <b>Problem</b>: What data does the sonar send to the other WasteService actors?
            Should it send a message for each detection?
            <alternative>
                <b>Possible solutions</b>:
                <ol>
                    <li>
                        Send a message <b>for each input data</b> detection. That solution
                        is the most flexible and general purpose to implement: we send everything
                        the sonar knows and let the Waste Service do the rest. However, that generates
                        an increase in bandwidth consumption, especially in the case the sonar performs
                        detections rapidly, and that could cause greater problems if
                        the service grows in size (<i>flexible but not much scalable</i>).
                    </li>
                    <li>
                        Send a message only <b>when the state changes</b>. That greatly reduces
                        the number of exchanged messages, saving bandwidth, and directly addresses the requirement.
                    </li>
                    <li>
                        <b>Hybrid approach</b> where we send every input data detection to a <b>middle component</b>,
                        which acts like a controller: it receives a sequence of distances, and mantains
                        the current state of the alarm (ON/OFF). Then, each time the state changes, propagate
                        a message to other contexts or to the actor which will detect the stop. The bandwidth
                        consumption depends on whether the sonar and the component are on the same or different nodes:
                        if the node is the same, then the only messages that are propagated are the ones on the state change.
                    </li>
                </ol>
            </alternative>
            
            <solution>
                <b>Solution</b>: Hybrid approach, using a <ksi>middle controller</ksi>, which sends 
                <code>stop</code> and <code>resume</code> events to the system.
                <br/>
                <b>Reasons</b>: the core-business doesn't care about the distance at all.
                In fact, from the Waste Service perspective,
                the sonar functions as a simple switch ON/OFF, which indicates if the system
                is in a state of alarm (distance &lt; DLIM) or not. Therefore, the only information
                needed to completely address the customer requirement, is <ksi>the change of the "alarm"
                state</ksi> (the alarm just started &rarr; stop, the alarm is over &rarr; resume).
                Why using events for stop/resume? Because even though the Transport Trolley
                is the main interested in detecting the message, the alarm concerns the whole
                Service Area and has no specific recipient.
            </solution>

            <h3 id="Stop-Resume">Stop/Resume</h3>

            <problem>What to stop</problem>
            <b>Problem</b>: <i>"what"</i> or <i>"which"</i> Transport Trolley actions can be
            stopped by the alarm message?
            <br/>
            <highlight1>We want to stop the movement: if the robot is still, while it's stopped it cannot
            star moving; if it was already moving, it must stop in place and remain still.</highlight1>

            <!--Ideally we want to stop the robot doing things. However, the robot can be really
            stopped only when it wants to move from a position to another, because it won't.
            -->

            <problem>When to stop</problem>
            <b>Problem</b>: <i>"when"</i> do we stop the robot while it's moving?
            <br/>
            <b>Considerations</b>: our robot moves in steps in the area, since
            the room is represented as a M x N matrix.<br/>
            If we consider a real situation, the stop could be caused by an emergency
            or could be due to dangerous circumstances. Therefore, we would need to stop the
            robot instantly.
            <alternative>
                <b>Possible solution</b>: stop the robot <b>as soon as the stop/alarm message is received</b>.
                A possible solution could be save the duration of the interrupted
                step and calculate the remaining time to complete it (a full step is 350ms).
                <br/>
                <b>Cons</b>: those calculations based on execution time are never 100% accurate, due to
                many factors (CPU/resources, network latency, unpredictable jitter, etc.).
                Moreover, in case the step total duration gets shortened or extended, the whole map
                representation could be affected, and cause it not to be accurate anymore.
            </alternative>
            
            <solution>
                <b>Solution</b>: for each step of the path, check if there is a stop/alarm event <ksi>only at the beginning or
                at the end of the step</ksi>.
                <br/>
                <b>Reasons</b>: the robot position gets updated only when a step is completed,
                so it might be easier to make the steps not interruptible; since our map
                has specific positions, identified by discrete coordinates, that solution
                can prevent the possibility of the robot to be located in between two different
                cells, and also reduces the possibility to get an out of sync situation between
                the robot position inside the map representation and its actual real position.
            </solution>
            
            <highlight1>FIX: add one state, to check if should stop, BEFORE the step</highlight1>
            
            <problem>How to stop</problem>
            <b>Problem</b>: <i>"how"</i> do we stop the robot while it's moving? How do we enter
            in a stop state? How do we resume from the stopped state? Who should handle those states?
            
            <br/>
            <b>Considerations</b>: a deposit action consists of a <ks><code>deposit</code></ks>
            request sent by the Waste Service to the Transport Trolley, which then sends a
            <ks><code>dopath</code></ks> request to the Path Executor, which finally sends the
            command/step to the Basic Robot.

            
            <solution>
                <b>Solution</b>: <ksi>handle the stop and resume from the pathexecutor</ksi> by adding a guard
                (<code>Transition t# whenEvent stop -> state_stop</code>) in those states that can be interrupted.
                <br/>
                <b>Reasons</b>: ideally we want to act on the transport trolley, but it's busy waiting
                for the pathexecutor reply, until the path is completed. Therefore, since the pathexecutor
                is the one responsible for scheduling the steps, to interact with it is the best solution,
                also considering the fact that it's located in the Transport Trolley context, acting like an
                actuator for the trolley.
            </solution>
            NB: the defined solution requires that we will have to modify the pathexecutor QAK actor code, we are going to rename 
            it <i>"pathexecutorbcr"</i>.

            <alternative>
                <b>Alternatives</b>: <highlight2>interrupt/returnFromInterrupt; prima soluzione provata</highlight2>
            </alternative>

            <h3 id="Led">Led</h3>
            What's the purpose of the led? Which components does it
            depend on? What information does it need?
            <br/>
            The Led is an output warning device, which is responsible for giving
            real-time information about the state of the transport trolley,
            and therefore it needs to access to data about it.

            <problem>Track Trolley State</problem>
            <b>Problem</b>: How do we keep track of the trolley state?
            <solution>
                <b>Solution</b>: make the <ksi>trolley state COAP observable</ksi> and use an actor
                to keep track of the current state of the Transport Trolley: <ks><code>trolleystateprovider</code></ks>.
                <br/>
                <b>Reasons</b>:
            </solution>
            <alternative>
                <b>Alternatives</b>: use a dispatch to update the state of the trolley
            </alternative>

            <h3 id="Extras">Extras</h3>
            <h4>Return to home/Go to pickup</h4>

            <h2 id="Raspberry-Pi-Components">Raspberry Pi Components</h2>
            
            <highlight1>Led behaviour</highlight1>
            How fast make it blink? Do some test and discover the optimal time
            <br/>
            <highlight2>Sonar distance capture intervals</highlight2>
            How many times per second the sonar must 

            <h2 id="Interactions">Interactions</h2>

            <h3 id="Messages">New Messages</h3>
            <table class="dictionary">
                <tr>
                    <th>Message</th>
                    <th>Type</th>
                    <th>Sender</th>
                    <th>Receiver</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>sonar_data</td>
                    <td>Dispatch</td>
                    <td>SonarDevice</td>
                    <td>AlarmController</td>
                    <td>
                        Contains the <ks><code>distance</code></ks> detected by the sonar device.
                    </td>
                </tr>
                <tr>
                    <td>stop</td>
                    <td>Event</td>
                    <td>AlarmController</td>
                    <td>PathExecutorBCR</td>
                    <td>
                        Indicates that the TransportTrolley activity must be stopped.
                    </td>
                </tr>
                <tr>
                    <td>resume</td>
                    <td>Event</td>
                    <td>AlarmController</td>
                    <td>PathExecutorBCR</td>
                    <td>
                        Indicates that the TransportTrolley activity can be resumed.
                    </td>
                </tr>
                <tr>
                    <td>coapUpdate</td>
                    <td>Dispatch</td>
                    <td>COAP framework</td>
                    <td>TrolleyStateProvider</td>
                    <td>
                        Built-in dispatch to notify when a COAP observed resource gets updated.
                        It contains 2 parameters: the resource name, and the associated value.
                    </td>
                </tr>
                <tr>
                    <td>trolley_state_changed</td>
                    <td>Dispatch</td>
                    <td>TrolleyStateProvider</td>
                    <td>LedController</td>
                    <td>
                        Message that notifies the LedController (component that communicate with the Led
                        device) that the Transport Trolley has entered a new state.
                    </td>
                </tr>
            </table>
            
            <h2 id="Logical-Architecture">Logical Architecture</h2>
            The Sprint2_ProblemAnalysis project aims to address the main issues
            of the warning/alarm features and give a first solution and implementation,
            using some simulators.
            <img width="100%" src="../../Sprint2_ProblemAnalysis/problem_analysis_logical_architecture_waste_service.png"/>
            QAK model: <a href="../../Sprint2_ProblemAnalysis/src/waste_service.qak">waste_service.qak</a>
            
            <h2 id="Test-Plans">Test Plans</h2>
            <table class="dictionary">
                <tr>
                    <th>Test</th>
                    <th>Involved Actors</th>
                    <th>Description</th>
                    <th>Files</th>
                </tr>
                <tr>
                    <td></td>
                    <td>
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </td>
                    <td></td>
                    <td>
                        QAK: <a href="">.qak</a>
                        Test: <a href="">.kt</a>
                    </td>
                    <!-- NB: to test the TypesProvider we can just use a TCP connection and analyze the reply content,
                        we don't need COAP, since it's a simple task to verify -->
                </tr>
            </table>
            <!-- 
                - How to run the tests
                - Test Reports(?)
            -->
        </div>

    </body>

</html>

<!--
<problem></problem>
<b>Problem</b>: 
<solution>
    <b>Solution</b>:
    <br/>
    <b>Reasons</b>:
</solution>
<b>Alternatives</b>:
-->