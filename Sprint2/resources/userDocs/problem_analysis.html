<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Sprint2</title>
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/code.css">
        <script type="text/javascript" src="../../../commons/resources/scripts/myScripts.js"></script>
    </head>

    <body onload="loadNav();">
        <div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
        <div id="sidenav" class="sidenav">
            <a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
            <a class="sprint" href="../../../Sprint0/index.html">Sprint0</a>
            <a class="sprint" href="../../../Sprint1/index.html">Sprint1</a>
            <a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
            <a href="../../index.html">Index</a>
            <a href="final_theme.html">Final Theme</a>
            <a href="requirement_analysis.html">Requirement<br/>Analysis</a>
            <a class="selected" href="problem_analysis.html">Problem Analysis</a>
            <div class="sidenavSection">
                <a href="#Logical-Architecture-from-Sprint1">Logical Architecture<br/>from Sprint1</a>
                <a href="#Defect-Analysis">Defect Analysis</a>
                <a href="#Sprint2-Software">Sprint2 Software</a>
                <div class="sidenavSubSection">
                    <a href="#Sonar">Sonar</a>
                    <a href="#Stop-Resume">Stop/Resume</a>
                    <a href="#Led">Led</a>
                    <a href="#Extra">Extra</a>
                </div>
                <a href="#Interactions">Interactions</a>
                <div class="sidenavSubSection">
                    <a href="#Messages">New Messages</a>
                </div>
                <a href="#Logical-Architecture">Logical Architecture</a>
                <a href="#Test-Plans">Test Plans</a>
                <div class="sidenavSubSection">
                    <a href="#Execute-Test">Execute Test</a>
                    <a href="#Test-Report">Test Report</a>
                </div>
            </div>
            <a href="project.html">Project</a>
            <a href="test_plans.html">Test Plans</a>
            <a href="conclusions.html">Conclusions</a>
            <a href="team.html">Team</a>
            <p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
            <a class="sprint" href="../../../Sprint3/index.html">Sprint3</a>
            <bottom-spacer/>
        </div>

        <div id="main">
            <h1 align="center">Problem Analysis</h1>
            Problematiche che possono verificarsi;
            <br/>
            Vedere quale software è disponibile e dove/come possiamo utilizzarlo;
            <br/>

            il problema principale è realizzare il meccanismo di stop/resume.
            E conseguentemente implementare il return a home.

        <!--
            <h2 id="Defects-Solving">Defects Solving</h2>
            
            <problem><a href="../../../Sprint1/resources/userDocs/conclusions.html#Bugs">Bug #7</a>: LoarRejected Blocked</problem>
            <b>Problem</b>: If a Smart Device sends a store request when the Waste Service is already
            handling a deposit action, the request isn't consumed even if the load cannot be accepted
            (differently from what we've considered in Sprint1 Problem Analysis).
            <br/>
            <b>Consideration</b>: this occurs because the implementation is based on a request/response model:
                the message in the Waste Service queue cannot be consumed because the Waste Service itself is waiting 
                for the Transport Trolley reply, while it's performing a deposit action. That suggests us that
                the request/response model does not suit the interaction needed to meet the requirement that
                "the truck driver must be sent off as soon as possible".
            <solution>
                <b>Solution</b>: use a <ksi>dispatch/dispatch interaction model</ksi> between the Waste Service and the Transport Trolley.
                <br/>
                <b>Reasons</b>: the dispatch/dispatch interaction allows the Waste Service <ksi>not to have to wait</ksi> for a
                reply from the Transport Trolley, which means it can handle other requests in the meantime.
            </solution>
            
            <h3>MapEditor</h3>
        -->
            <h2 id="Logical-Architecture-from-Sprint1">Logical Architecture from Sprint1</h2>
            <img width="100%" src="../../../Sprint1/Sprint1_Project/sprint1_waste_service/project_logical_architecture_core-business.png"/>
            QAK model: <a href="../../../Sprint1/Sprint1_Project/sprint1_waste_service/src/waste_service.qak">waste_service.qak</a>

            <h2 id="Defects-Analysis">Defects Analysis</h2>
            <problem><a href="../../../Sprint1/resources/userDocs/conclusions.html#Bugs">Bug #6</a> Windows Build</problem>
            <b>Considerations</b>:
            <br/>
            This bug requires further investigations for us to understand how the Flutter framework translates and treats the Dart TCP sockets code.
            
            <solution>
                Since that exceedes the objectives of our project and is a <i>minor issue</i> (given the fact that the user can still
                use and will probably prefer the Android version), we decide <ksi>not to solve it</ksi>, at least 
                for the moment. Therefore we opened an <a href="https://github.com/iss2022-BCR/WasteService/issues/11">issue</a> on the GitHub repository and added the "wontfix" label.
            </solution>

            <problem><a href="../../../Sprint1/resources/userDocs/conclusions.html#Bugs">Bug #7</a>: loadrejected</h4></problem>
            <solution><b>Possible solution</b>:
                <br/>
                we could add one more SmartDevice-WasteService interaction before the store request:
                by introducing a <b>new actor</b>, the SmartDevice could ask if there is enough space for the deposit,
                and after getting the reply, if it's positive it would send a store request.
            </solution>
            <consideration>
                This solution would work but it presents some issues:
                <ul>
                    <li>
                        There's a small window of time in which another SmartDevice could
                        send the store request "stealing" the priority for the deposit.
                    </li>
                    <li>
                        The loadrejected reply to the storerequest would lose value,
                        since we know for sure that a storerequest can be sent only if
                        a SmartDevice knows there's enough space.
                    </li>
                </ul>
                For these reasons, at the moment we decide not to spend further time
                analyzing and/or implementing that issue, and therefore <ksi>not to solve it</ksi>:
                we stick with the solution we already developed.
                Therefore we opened an <a href="https://github.com/iss2022-BCR/WasteService/issues/12">issue</a> on the GitHub repository and added the "wontfix" label.
            </consideration>
            

            <h2 id="Sprint2-Software">Sprint2 Software</h2>
            The Sprint 2 software will be the product of the analysis of problems
            related to the Raspberry Pi.
            We will analyze the main problems of the <b><i>4th requirement</i></b>, and discuss the
            possible solutions and their differences.
            <br/>
            <br/>
            Since the Raspberry Pi is situated on a computational node different from
            the Waste Service one, we will need to add a new context, which we're going
            to call "<ksi>ctx_raspberry</ksi>".
            The actors of this context will be running on the Raspberry Pi device.
            
            <h3 id="Sonar">Sonar</h3>
            What's the purpose of the sonar? Which components depend on it and where will
            them be located?
            <br/>
            NB: The sonar is an input alarm device, which is related to the stop/resume functionality.
            
            <problem>Get input from the component HC-SR04</problem>
            The sonar needs to get the input from the physical component (HC-SR04)

            <br/>
            For the problem analysis test plans we're going to use an actor that simulates
            the sonar input component, in localhost.
            <highlight3>What kind of interaction? Polling? , constantly sending a request to the sonar?
            </highlight3>
            <b>NO!! Parlare solo del tipo di interazione qui. Il resto lo diciamo dopo.</b>
            Solution: separate the sonar raw data receiver from the stopper:<br/>
            - a component constantly get the raw data from the sonar component and sends the distance to a controller;
            <br/>
            - the controller receives all the sonar data containing the distance, and check when
            the distance decrease below or increase over the threshold sending a stop/resume message,
            emitting respectively stop/resume events. 
            
            <problem>Sonar data sent</problem>
            <b>Problem</b>: What data does the sonar send to the other WasteService actors?
            Should it send a message for each detection?
            <alternative>
                <b>Possible solutions</b>:
                <ol>
                    <li>
                        Send a message <b>for each input data</b> detection. That solution
                        is the most flexible and general purpose to implement: we send everything
                        the sonar knows and let the Waste Service do the rest. However, that generates
                        an increase in bandwidth consumption, especially in the case the sonar performs
                        detections rapidly, and that could cause greater problems if
                        the service grows in size (<i>flexible but not much scalable</i>).
                    </li>
                    <li>
                        Send a message only <b>when the state changes</b>. That greatly reduces
                        the number of exchanged messages, saving bandwidth, and directly addresses the requirement.
                    </li>
                    <li>
                        <b>Hybrid approach</b> where we send every input data detection to a <b>middle component</b>,
                        which acts like a controller: it receives a sequence of distances, and mantains
                        the current state of the alarm (ON/OFF). Then, each time the state changes, propagate
                        a message to other contexts or to the actor which will detect the stop. The bandwidth
                        consumption depends on whether the sonar and the component are on the same or different nodes:
                        if the node is the same, then the only messages that are propagated are the ones on the state change.
                    </li>
                </ol>
            </alternative>
            
            <solution>
                <b>Solution</b>: Hybrid approach, using a <ksi>middle controller</ksi>, which sends 
                <code>stop</code> and <code>resume</code> events to the system.
                <br/>
                <b>Reasons</b>: the core-business doesn't care about the distance at all.
                In fact, from the Waste Service perspective,
                the sonar functions as a simple switch ON/OFF, which indicates if the system
                is in a state of alarm (distance &lt; DLIM) or not. Therefore, the only information
                needed to completely address the customer requirement, is <ksi>the change of the "alarm"
                state</ksi> (the alarm just started &rarr; stop, the alarm is over &rarr; resume).
                Why using events for stop/resume? Because even though the Transport Trolley
                is the main interested in detecting the message, the alarm concerns the whole
                Service Area and has no specific recipient.
            </solution>

            <h3 id="Stop-Resume">Stop/Resume</h3>

            <problem>What to stop</problem>
            <b>Problem</b>: <i>"what"</i> or <i>"which"</i> Transport Trolley actions can be
            stopped by the alarm message?
            <br/>
            <highlight1>We want to stop the movement: if the robot is still, while it's stopped it cannot
            star moving; if it was already moving, it must stop in place and remain still.</highlight1>

            <!--Ideally we want to stop the robot doing things. However, the robot can be really
            stopped only when it wants to move from a position to another, because it won't.
            -->

            <problem>When to stop</problem>
            <b>Problem</b>: <i>"when"</i> do we stop the robot while it's moving?
            <br/>
            <b>Considerations</b>: our robot moves in steps in the area, since
            the room is represented as a M x N matrix.<br/>
            If we consider a real situation, the stop could be caused by an emergency
            or could be due to dangerous circumstances. Therefore, we would need to stop the
            robot instantly.
            <alternative>
                <b>Possible solution</b>: stop the robot <b>as soon as the stop/alarm message is received</b>.
                A possible solution could be save the duration of the interrupted
                step and calculate the remaining time to complete it (a full step is 350ms).
                <br/>
                <b>Cons</b>: those calculations based on execution time are never 100% accurate, due to
                many factors (CPU/resources, network latency, unpredictable jitter, etc.).
                Moreover, in case the step total duration gets shortened or extended, the whole map
                representation could be affected, and cause it not to be accurate anymore.
            </alternative>
            
            <solution>
                <b>Solution</b>: for each step of the path, check if there is a stop/alarm event <ksi>only at the beginning or
                at the end of the step</ksi>.
                <br/>
                <b>Reasons</b>: the robot position gets updated only when a step is completed,
                so it might be easier to make the steps not interruptible; since our map
                has specific positions, identified by discrete coordinates, that solution
                can prevent the possibility of the robot to be located in between two different
                cells, and also reduces the possibility to get an out of sync situation between
                the robot position inside the map representation and its actual real position.
            </solution>
            
            <highlight1>FIX: add one state, to check if should stop, BEFORE the step</highlight1>
            
            <problem>How to stop</problem>
            <b>Problem</b>: <i>"how"</i> do we stop the robot while it's moving? How do we enter
            in a stop state? How do we resume from the stopped state? Who should handle those states?
            
            <br/>
            <b>Considerations</b>: a deposit action consists of a <ks><code>deposit</code></ks>
            request sent by the Waste Service to the Transport Trolley, which then sends a
            <ks><code>dopath</code></ks> request to the Path Executor, which finally sends the
            command/step to the Basic Robot.

            
            <solution>
                <b>Solution</b>: <ksi>handle the stop and resume from the pathexecutor</ksi> by adding a guard
                (<code>Transition t# whenEvent stop -> state_stop</code>) in those states that can be interrupted.
                <br/>
                <b>Reasons</b>: ideally we want to act on the transport trolley, but it's busy waiting
                for the pathexecutor reply, until the path is completed. Therefore, since the pathexecutor
                is the one responsible for scheduling the steps, to interact with it is the best solution,
                also considering the fact that it's located in the Transport Trolley context, acting like an
                actuator for the trolley.
            </solution>
            NB: the defined solution requires that we will have to modify the pathexecutor QAK actor code, we are going to rename 
            it <i>"pathexecutorbcr"</i>.

            <alternative>
                <b>Alternatives</b>: <highlight2>interrupt/returnFromInterrupt; prima soluzione provata</highlight2>
            </alternative>

            <h3 id="Led">Led</h3>
            What's the purpose of the led? Which components does it
            depend on? What information does it need?
            <br/>
            NB: The Led is an output warning device, which is responsible for giving
            real-time information about the state of the transport trolley,
            and therefore it needs to access its data.

            <problem>Track Trolley State</problem>
            <b>Problem</b>: How do we keep track of the trolley state?
            <solution>
                <b>Solution</b>: separate the trolley state from the led, make the
                <ksi>trolley state COAP observable</ksi> and use an actor
                to keep track of the current state of the Transport Trolley: <ks><code>trolleystateprovider</code></ks>.
                <br/>
                <pre>
                    TROLLEY_STATE := HOME | MOVING | PICKUP | DUMP | STOPPED
                </pre>

                <pre>
                    LED_STATE := ON | BLINKING | OFF
                </pre>
                <b>Reasons</b>:
                <highlight1>TODO</highlight1>
            </solution>
            <alternative>
                <b>Alternatives</b>: use a dispatch to update the state of the trolley
            </alternative>

            <h3 id="Extras">Extras</h3>
            <h4>Return to home/Go to pickup</h4>

            <h2 id="Raspberry-Pi-Components">Raspberry Pi Components</h2>
            
            <highlight1>Led behaviour</highlight1>
            How fast make it blink? Do some test and discover the optimal time
            <br/>
            <highlight2>Sonar distance capture intervals</highlight2>
            How many times per second the sonar must 

            <h2 id="Interactions">Interactions</h2>

            <h3 id="Messages">New Messages</h3>
            <table class="dictionary">
                <tr>
                    <th>Message</th>
                    <th>Type</th>
                    <th>Sender</th>
                    <th>Receiver</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>sonar_data</td>
                    <td>Dispatch</td>
                    <td>SonarDevice</td>
                    <td>AlarmController</td>
                    <td>
                        Contains the <ks><code>distance</code></ks> detected by the sonar device.
                    </td>
                </tr>
                <tr>
                    <td>stop</td>
                    <td>Event</td>
                    <td>AlarmController</td>
                    <td>PathExecutorBCR</td>
                    <td>
                        Indicates that the TransportTrolley activity <ks><code>must be stopped</code></ks>.
                    </td>
                </tr>
                <tr>
                    <td>resume</td>
                    <td>Event</td>
                    <td>AlarmController</td>
                    <td>PathExecutorBCR</td>
                    <td>
                        Indicates that the TransportTrolley activity <ks><code>can be resumed</code></ks>.
                    </td>
                </tr>
                <tr>
                    <td>coapUpdate</td>
                    <td>Dispatch</td>
                    <td>COAP framework</td>
                    <td>TrolleyStateProvider</td>
                    <td>
                        Built-in dispatch to notify when a COAP observed resource gets updated.
                        It contains 2 parameters: the resource name, and the associated value.
                    </td>
                </tr>
                <tr>
                    <td>trolley_state_changed</td>
                    <td>Dispatch</td>
                    <td>TrolleyStateProvider</td>
                    <td>LedController</td>
                    <td>
                        Message that notifies the LedController (component that communicate with the Led
                        device) that the Transport Trolley has entered a new state.
                    </td>
                </tr>
            </table>
            
            <h2 id="Logical-Architecture">Logical Architecture</h2>
            The <a href="../../Sprint2_ProblemAnalysis/">Sprint2_ProblemAnalysis</a> project aims to address the main issues
            of the warning/alarm features and give a first solution and implementation,
            using some simulators.
            <img width="100%" src="../../Sprint2_ProblemAnalysis/sprint2_waste_service_analysisarch_edited.png"/>
            QAK model: <a href="../../Sprint2_ProblemAnalysis/src/waste_service.qak">waste_service.qak</a>
            
            <h2 id="Test-Plans">Test Plans</h2>
            <table class="dictionary">
                <tr>
                    <th>Test</th>
                    <th>Involved Actors</th>
                    <th>Description</th>
                    <th>Files</th>
                </tr>
                <tr> 
                    <td>Stop/Resume Test</td>
                    <td>
                        <ul>
                            <li>Mock_WasteService</li>
                            <li>TransportTrolley</li>
                            <li>PathExecutorBCR</li>
                            <li>Mock_Sonar</li>
                            <li>AlarmController</li>
                        </ul>
                    </td>
                    <td>
                        We check if the TransportTrolley actor:
                        <ol>
                            <li>
                                correctly stops its activity when the AlarmController
                                receives a distance <b>less than</b> <ks><code>DLIM</code></ks> from the sonar;
                            </li>
                            <li>
                                correctly resumes its activity when the AlarmController
                                receives a distance <b>greater than</b> <ks><code>DLIM</code></ks> from the sonar;
                            </li>
                        </ol>
                    </td>
                    <td>
                        QAK: <a href="../../Sprint2_ProblemAnalysis/src/test_stop_resume.qak">test_stop_resume.qak</a>
                        Test: <a href="../../Sprint2_ProblemAnalysis/test/it/unibo/wasteservice/TestStopResume.kt">TestStopResume.kt</a>
                    </td>
                </tr>
                <tr>
                    <td>Trolley State Test</td>
                    <td>
                        <ul>
                            <li>Mock_WasteService</li>
                            <li>TransportTrolley</li>
                            <li>PathExecutorBCR</li>
                            <li>TrolleyStateProvider</li>
                            <li>Mock_Sonar</li>
                            <li>AlarmController</li>
                        </ul>
                    </td>
                    <td>
                        We check if the Led state correctly gets updates when
                        the TransportTrolley changes:
                        <ol>
                            <li>When the TransportTrolley is <code>AT HOME</code>, the led is <ks><code>OFF</code></ks>;</li>
                            <li>When the TransportTrolley is <code>MOVING</code>, the led is <ks><code>BLINKING</code></ks>;</li>
                            <li>When the TransportTrolley is <code>STOPPED</code>, the led is <ks><code>ON</code></ks>;</li>
                        </ol>
                    </td>
                    <td>
                        QAK: <a href="../../Sprint2_ProblemAnalysis/src/test_led_state.qak">test_led_state.qak</a>
                        Test: <a href="../../Sprint2_ProblemAnalysis/test/it/unibo/wasteservice/TestLedState.kt">TestLedState.kt</a>
                    </td>
                </tr>
                <!--<tr> TO-DO
                    <td>Return Home Test</td>
                    <td>
                        <ul>
                            <li></li>
                            <li></li>
                        </ul>
                    </td>
                    <td></td>
                    <td>
                        QAK: <a href="">.qak</a>
                        Test: <a href="">.kt</a>
                    </td>
                </tr>-->
            </table>

            <h3 id="Execute-Test">Execute Test</h3>
            To execute all the tests, run the following command:
            <pre>
                ./gradlew test
            </pre>
            
            <h3 id="Test-Report">Test Report</h3>
            The test report is generated automatically and is available here: <a href="../../Sprint2_ProblemAnalysis/build/reports/tests/test/index.html">index.html</a>.

        </div>

    </body>

</html>

<!--
<problem></problem>
<b>Problem</b>: 
<solution>
    <b>Solution</b>:
    <br/>
    <b>Reasons</b>:
</solution>
<b>Alternatives</b>:
-->