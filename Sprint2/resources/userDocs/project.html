<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Sprint2</title>
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/code.css">
        <script type="text/javascript" src="../../../commons/resources/scripts/myScripts.js"></script>
    </head>

    <body onload="loadNav();">
        <div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
        <div id="sidenav" class="sidenav">
            <a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
            <a class="sprint" href="../../../Sprint0/index.html">Sprint0</a>
            <a class="sprint" href="../../../Sprint1/index.html">Sprint1</a>
            <a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint2 &#8212;&#8211;</a>
            <a href="../../index.html">Index</a>
            <a href="final_theme.html">Final Theme</a>
            <a href="requirement_analysis.html">Requirement<br/>Analysis</a>
            <a href="problem_analysis.html">Problem Analysis</a>
            <a class="selected" href="project.html">Project</a>
            <div class="sidenavSection">
                <a href="#Defects-Solution">Defects-Solution</a>
                <a href="#Logical-Architecture">Logical Architecture</a>
                <a href="#WasteService">WasteService</a>
                <div class="sidenavSubSection">
                    <a href="#Waste-Service-Updated-Logical-Architecture">Waste Service Updated<br/>Logical Architecture</a>
                    <a href="#Waste-Service-Upgrades">Waste Service Upgrades</a>
                    <a href="#Waste-Service-Bug-Fixes">Waste Service<br/>Bug Fixes</a>
                </div>
                <a href="#RadarSystem22-DomainBCR">RadarSystem22.<br/>DomainBCR</a>
                <div class="sidenavSubSection">
                    <a href="#Scripts-and-Programs">Scripts and Programs</a>
                    <a href="#Led-and-Sonar-Changes">Led and Sonar Changes</a>
                    <a href="#Buzzer-Component">Buzzer Component</a>
                    <a href="#TextDisplay-Component">TextDisplay Component</a>
                    <a href="#DomainSystemConfig-Changes">DomainSystemConfig Changes</a>
                </div>
                
                <a href="#Software-Name">&lt;Software Name&gt;</a>
                <div class="sidenavSubSection">
                </div>
                <a href="#Deployment">Deployment</a>
                <a href="#Raspberry-Demo">Raspberry Demo</a>
            </div>
            <a href="test_plans.html">Test Plans</a>
            <a href="conclusions.html">Conclusions</a>
            <a href="team.html">Team</a>
            <p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
            <a class="sprint" href="../../../Sprint3/index.html">Sprint3</a>
            <bottom-spacer/>
        </div>

        <div id="main">
            <h1 align="center">Project</h1>
            The project contains all the software our team developed to achieve the Sprint2 SCRUM goal.

            <h2 id="Defects-Solution">Defects Solution</h2>
            <h3>SmartDevice</h3>
            We upgraded the <ksi>SmartDevice</ksi> application to include a Menu and a <kc>Settings page</kc>.
            This page allows the user to change the <i>message parameter</i>:
            <ul>
                <li>message <b>ID</b>;</li>
                <li>message <b>type</b>;</li>
                <li><b>sender</b> actor name;</li>
                <li><b>receiver</b> actor name.</li>
            </ul>
            If the parameters are different from the ones for the WasteService <ks><code>storerequest</code></ks>,
            the view for the sending interface is simple. 
            <h4>Views</h4>
            <img width="200px" src="../imgs/project/SmartDeviceSimulator_Settings.png">
            <img width="200px" src="../imgs/project/SmartDeviceSimulator_SendMessageInterface.png">

            <h3>MapEditor</h3>
            We upgraded the <ksi>MapEditor</ksi> application to fix/implement the following <kc>features</kc>:
            <ul>
                <li><code>roomMap</code> and <code>mapConfig</code> objects loading from file
                    and saving to file with path tracking from settings;</li>
                <li>File errors handling;</li>
                <li>Persistent settings;</li>
                <li>Logger (to console and to file).</li>
            </ul>

            <h2 id="Logical-Architecture">Logical Architecture</h2>
            As the project is starting to grow considerably in size, we decided to
            split the system in 2 parts, one for each node:

            <ul>
                <li>
                    WasteService Core
                    <img width="100%" src="../../Sprint2_Project/sprint2_wasteservice/sprint2_waste_servicearch_no_extension_edited.png"/>
                    QAK model: <a href="../../Sprint2_Project/sprint2_wasteservice/src/wasteservice_core_no_extension.noqak">wasteservice_core_no_extension.noqak</a>
                </li>
                <li>
                    Raspberry Pi
                    <img width="100%" src="../../Sprint2_Project/sprint2_raspberry_pi/sprint2_raspberry_pi_no_extensionarch_edited.png"/>
                    QAK model: <a href="../../Sprint2_Project/sprint2_raspberry_pi/src/wasteservice_rpi_no_extension.noqak">wasteservice_rpi_no_extension.noqak</a>
                </li>
            </ul>
            
            <h2 id="WasteService">Sprint2.1: WasteService</h2>
            We upgraded the <ksi>Waste Service</ksi> (<a href="../../Sprint2_Project/sprint2_wasteservice/">sprint2_wasteservice</a>) project to make it
            easier for us to integrate the Raspberry Pi functionalities.
            
            <h3 id="Waste-Service-Updated-Logical-Architecture">Waste Service Updated Logical Architecture</h3>
            <img width="100%" src="../../Sprint2_Project/sprint2_wasteservice/sprint2_waste_servicearch_edited.png"/>
            QAK model: <a href="../../Sprint2_Project/sprint2_wasteservice/src/wasteservice_core.qak">wasteservice_core.qak</a>

            <h3 id="Waste-Service-Upgrades">Waste Service Upgrades</h3>
            The remarkable changes are the following:

            <h4>Stop/Resume feature</h4>
            To support the stop/resume functionality, we modified the pathexecutor QAK
            actor (renamed to PathExecutorBCR):
            <div class="remark">
                When PathExecutorBCR detects a stop event, if it's performing a task
                it <b>finishes the current action</b>, then enters the STOP state, which will
                cause it to ignore any other request, until a RESUME event is detected.
            </div>
            In particular:
            <ul>
                <li>We added a guard checking for stop events (<code>Transition t1 whenEvent stop -> state_stop</code>) at the end of the following states:
                    <ul>
                        <li>state_idle (the state where the actor waits for path requests);</li>
                        <li>state_do_move_forward;</li>
                        <li>state_do_move_turn.</li>
                    </ul>
                </li>
                <li>
                    We added the state "<ks><code>state_stop</code></ks>"
<pre style="white-space: pre;">
State state_stop {
    [# var PathTodo = pathut.getPathTodo() #]
    println("[PathExecutorBCR] Alarm detected, trolley stopped. Path to do: $PathTodo")
}
Transition t3 whenEvent resume -> state_resume
</pre>
                </li>
                <li>
                    We added the state "<ks><code>state_resume</code></ks>"
<pre style="white-space: pre;">
State state_resume {
    println("[PathExecutorBCR] Alarm retracted. Resuming...")
}
Goto state_next_move if [# MovesDone.length != TotPathMoves #] else state_idle
</pre>
                </li>
            </ul>

            <h4>TransportTrolley State</h4>
            <div class="remark">
                When the Transport Trolley performs an action, arrives at HOME or
                becomes stopped/resumed, its state changes and is notified to the rest
                of the system, so that the interested components (e.g the Led) can
                get updated.
            </div>

            To track the Transport Trolley state and make it COAP observable
            since the QAK framework already supports COAP:
            
            <ul>
                <li>
                    We created a new enum class <code>TransportTrolleyState</code>
<pre style="white-space: pre;">
enum class TransportTrolleyState {
    NONE, HOME, MOVING, PICKUP, DUMP, STOPPED;

    companion object {
        fun parseFromMessage(s: String): TransportTrolleyState
    }
}
</pre>
                    <b>NB</b>: The TransportTrolley state is different from the Led state.
                </li>
                <li>
                    We added a call to <b>update the COAP resource</b> idicating the Transport Trolley
                    state
                    <pre>
                        updateResource [# "transporttrolley(STATE)" #]
                    </pre>
                    inside the involved actors:
                    <ul>
                        <li>TransportTrolley</li>
                        <li>PathExecutor</li>
                    </ul>
                </li>
                <li>
                    Created an actor that acts as an observer of the COAP
                    resource: the actor <ks><code>TrolleyStateProvider</code></ks>
                    registers itself to the COAP observable resource:
                    <pre>
                        observeResource transporttrolley
		                observeResource pathexecutorbcr
                    </pre>
                    and generates an event (that other actors can detect) whenever the state changes:
<pre style="white-space: pre;">
onMsg(coapUpdate: coapUpdate(RESOURCE, VALUE)) {
    // Check if the state changed
    if [# wasteservice.TransportTrolleyState.parseFromMessage(payloadArg(1)) != TTState #] {
        [# TTState = wasteservice.TransportTrolleyState.parseFromMessage(payloadArg(1)) #]
        
        // Emit event
        emit trolley_state_changed: trolley_state_changed($TTState)
    }
}
</pre>
                </li>
            </ul>

            <h3 id="Waste-Service-Bug-Fixes">Waste Service Bug Fixes</h3>
            <problem>Bug: <a href="https://github.com/iss2022-BCR/WasteService/issues/24">Pickup/Dump Trolley State</a></problem>
            <b>Problem</b>: the PICKUP and DUMP trolley states were arriving too late and that caused for
            example the LED to never turn ON when the trolley was performing those actions.
            <solution>
                <b>Solution</b>: fix the implementation of <code>simulateAction()</code>,
                by using <code>delay()</code> instead of <code>Thread.sleep()</code>.
                <br/>
                <b>Reason</b>: QAK actors of the same context run on the same thread,
                therefore when calling <code>Thread.sleep()</code> they would get all blocked,
                the TrolleyStateProvider too, preventing it from processing the <code>coapUpdate()</code>. 
            </solution>
            
            <problem>Bug: <a href="https://github.com/iss2022-BCR/WasteService/issues/25">Home/Moving Trolley State</a></problem>
            <b>Problem</b>: after completing at least one deposit, when the Transport Trolley returns at home,
            if a stop event is detected and the Transport Trolley enters the STOPPED state, when resuming the
            PathExecutor mistakenly propagates the state MOVING, instead of HOME.

            <h2 id="RadarSystem22-DomainBCR">Sprint 2.2: RadarSystem22.DomainBCR</h2>
            Before implementing the Raspberry Pi QAK, we needed something to use the real/simulated
            components.
            <br/><br/>

            To achieve this goal, we developed <ksi>RadarSystem22.DomainBCR</ksi>
            (<a href="../../Sprint2_Project/it.unibo.radarSystem22.domainBCR/">it.unibo.radarSystem22.domainBCR</a>),
            which we obtained by modifying the project provided by the customer:
            <a href="https://github.com/anatali/issLab2022/tree/main/it.unibo.radarSystem22.domain">it.unibo.radarSystem22.domain</a>.
            
            <h3 id="Scripts-and-Programs">Scripts and Programs</h3>
            The RadarSystem22.domain project used some scripts and programs which were
            already provided by the customer: <a href="../../Sprint2_Project/misc/SonarAlone.c">SonarAlone.c</a>,
            <a href="../../Sprint2_Project/misc/led25GpioTurnOn.sh">led25GpioTurnOn.sh</a>,
            <a href="../../Sprint2_Project/misc/led25GpioTurnOff.sh">led25GpioTurnOff.sh</a>).
            However, we decided to recreate them using Python scripts, for a number of reasons:
            <ul>
                <li>
                    <b>portability</b>, since they wouldn't depend on libraries like WiringPi which is not supported
                    anymore and generates problems with new Raspberry OS versions;
                </li>
                <li>
                    <b>consistency</b> and <b>homogeneity</b>, since this way they all use the
                    python interpreter and packages. That also makes it possible to avoid for example
                    problems related to the End-Of-Line characters, which are different from
                    Windows and Linux (a bash script written on a Windows OS won't work in Linux
                    unless the EOF characters get replaced);
                </li>
                <li>
                    <b>Ease of use and deployment</b>, Python is easy to install and already shipped with
                    Raspberry OS images. Python scripts also doesn't need to be compiled, which is one
                    operation less to do during the deployment phase. 
                </li>
            </ul>
            For these reason we developed the following scripts:
            <ul>
                <li>
                    <a href="../../Sprint2_Project/scripts/raspberry/sonarBCR.py"><ksi>sonarBCR.py</ksi></a> - is used to
                    get the distance (in CM) from the SC-HR04 component. It uses the <b>GPIO 23</b> (Pin #16/40) as Trigger,
                    and <b>GPIO 24</b> (Pin #18/40) as Echo.<br/>
                    With the <code>loop</code> parameter (and optionally the delay) the script continuously
                    prints the detected distance, until the user interrupts it.
                </li>
                <li>
                    <a href="../../Sprint2_Project/scripts/raspberry/ledBCR.py"><ksi>ledBCR.py</ksi></a> - is used to
                    turn ON/OFF a Led component or make it blink. It uses the <b>GPIO 25</b> (Pin #22/40).
                    The state (on / off / blink) must be passed as a parameter. When blinking, the script keeps
                    running until the user interrupts it.
                </li>
                <li>
                    <a href="../../Sprint2_Project/scripts/raspberry/buzzerBCR.py"><ksi>buzzerBCR.py</ksi></a> - is used to
                    turn ON/OFF a Buzzer component or make it intermittent. It uses the <b>GPIO 18</b> (Pin #12/40).
                    The state (on / off / intermittent) must be passed as a parameter. When intermittent, the script keeps
                    running until the user interrupts it.
                </li>
                <li>
                    <a href="../../Sprint2_Project/scripts/raspberry/displayBCR.py"><ksi>displayBCR.py</ksi></a> - is used to
                    write on a text display LCD 1602 (16 characters per line, 2 lines) with a I2C expander module. It uses the
                    special GPIOs <b>GPIO 2</b> (Pin #3/40) and <b>GPIO 3</b> (Pin #5/40) which are needed to use the I2C interface.
                    The script accepts 2 parameters which are the strings (characters sequence) to be passed to the component.
                    If no paramters are passed, the script clears the display.
                </li>
            </ul>
            <a href="https://it.pinout.xyz/pinout/">Raspberry Pi Pinout reference</a>.

            <h3 id="Led-and-Sonar-Changes">Led and Sonar Changes</h3>
            We updated the <code>ILed</code> interface to add the method <code>blink()</code>
            which should make the Led to blink the led flash at intervals of time:
<pre style="white-space: pre;">
public interface ILed extends IDevice {
    public void turnOn();
    public void turnOff();
    public void blink();
    public LedState getState();
}
</pre>

            We implemented the mock version of the <code>blink()</code> method by 
            using a Thread which turns the Led ON and OFF at intervals of time delayed by
            a number of milliseconds:
<pre style="white-space: pre;">
@Override // LedMock
public void blink()
{
    if(getState().equals(LedState.BLINKING))
        return;

    super.blink();
    blinker = new Thread(new Runnable() {
        private boolean isOn = false;
        @Override
        public void run() {
            while(getState().equals(LedState.BLINKING)) {
                isOn = !isOn;

                panel.setSize(isOn ? sizeOn : sizeOff);
                panel.setBackground(isOn ? colorOn : colorOff);

                panel.validate();
                panel.repaint();

                BasicUtils.delay(DomainSystemConfig.ledDelay);
            }
        }
    });

    blinker.start();
}
</pre>
            We also changed the concrete implementation of both Led and Sonar
            in order to make them use our new python scripts.
<pre style="white-space: pre;">
/usr/bin/python3 -u ./ledBCR.py &lt;on | off | blink [delay]&gt;
/usr/bin/python3 -u ./sonarBCR.py &lt;loop [delay]&gt;
</pre>

            <h3 id="Buzzer-Component">Buzzer Component</h3>
            The buzzer component is almost identical to the Led one. We implemented
            an <code>IBuzzer</code> interface and then mock/concrete classes:
<pre style="white-space: pre;">
public interface IBuzzer extends IDevice {
    public void turnOn();
    public void turnOff();
    public void turnIntermittent();
    public BuzzerState getState();
}
</pre>
            To implement the mock we used the <code>javax.sound</code> library
            to play a "beep" sound effect:
<pre style="white-space: pre;">
try {
    URL url = new URL("https://www.soundjay.com/buttons/beep-09.wav");
    clip = AudioSystem.getClip();

    AudioInputStream ais = AudioSystem.getAudioInputStream(url);
    clip.open(ais);
}
catch (Exception e) {e.printStackTrace();}
</pre>

            <h3 id="TextDisplay-Component">TextDisplay Component</h3>
            To implement the TextDisplay component we first created an <code>ITextDisplay</code> interface:
<pre style="white-space: pre;">
public interface ITextDisplay extends IDevice {
    public void setLines(String text1, String text2);
    public String getLine1();
    public String getLine2();
    public void clear();
}
</pre>
            Then we implemented a mock version of the device, which creates a GUI with
            2 text boxes to simulate the output of the display:
<pre style="white-space: pre;">
protected void configure()
{
    textField1 = new TextField();
    textField1.setEditable(false);
    textField1.setColumns(16);
    textField1.setFont(new Font(Font.MONOSPACED, Font.BOLD, 16));
    textField2 = new TextField();
    textField2.setEditable(false);
    textField2.setColumns(16);
    textField2.setFont(new Font(Font.MONOSPACED, Font.BOLD, 16));
    frame.add(BorderLayout.PAGE_START, textField1);
    frame.add(BorderLayout.PAGE_END, textField2);
}
</pre>
            <img src="../../resources/imgs/project/TextDisplayMockGUI.png">
            <br/><br/>
            Finally we implemented the concrete version which simply executes the
            <code>displayBCR.py</code> script passing the text as parameters:
<pre style="white-space: pre;">
    @Override
    protected void textDisplayActivate(String text1, String text2)
    {
        String[] command = { "/usr/bin/python3", "-u", "./displayBCR.py", getLine1(), getLine2()};
        ProcessBuilder builder = new ProcessBuilder(command);

        String className = "[" + this.getClass().getSimpleName() + "]";
        ColorsOut.out(className + " Line1: " + getLine1());
        ColorsOut.out(className.replaceAll("(?s)(?&lt;!\\\\S).(?!\\\\S)", " ") + " Line2: " + getLine2());

        try { builder.start(); }
        catch(IOException e) { System.out.println("[" + this.getClass().getSimpleName() + "] ERROR: " +  e.getMessage()); }
    }
</pre>

            <h3 id="DomainSystemConfig-Changes">DomainSystemConfig Changes</h3>
            To make the system more customizable at runtime, we extended the
            <code>DomainSystemConfig</code> class too. In particular, we added:
            <ul>
                <li><code>sonarDelay</code> - used to delay the sonar detections.</li>
                <li>
                    <code>ledDelay</code> and <code>buzzerDelay</code> - used to choose how quickly
                    the led and buzzer must blink/beep.
                </li>
                <li>
                    <code>enableBuzzer</code> and <code>enableTextDisplay</code> - used to
                    enable/disable the usage of the buzzer and display components (since they're not
                    specifically required by the customer).
                </li>
                <li>
                    <code>textLine1Delay</code> and <code>textLine2Delay</code> - used to
                    limit the display refresh rate (may be different for each line).
                </li>
            </ul>

            <h2 id="Raspberry-Pi">Sprint 2.3: Raspberry Pi</h2>
            <h3 id="Device">Device</h3>
            The device used is a <a href="https://www.raspberrypi.com/products/raspberry-pi-4-model-b/">Raspberry Pi 4 Model B</a>: <highlight1>Specifiche</highlight1>
            <br/>

            <h4>Pin scheme and components</h4>
            
            <h4>Setup</h4>
            <ul>
                <li>ssh/vnc</li>
                <li>Make sure python is installed</li>
            </ul>
            <highlight1>Setup SSH without password</highlight1>
            
            <h3>Sonar</h3>
            Per implementare la feature del sonar, abbiamo preso un progetto fornito dalla nostra
            software house (sonarqak) e ne abbiamo ricavato una versione specializzata:
            abbiamo creato degli script python per diverse funzionalità

            <ol>
                <li>SonarAloneBCR.c</li>
                <li>buzzerBCR.py</li>
                <li>displayBCR.py</li>
                <li>sonarBCR.py</li>
                <li>ledBCR.py</li>
            </ol>

            Inizialmente abbiamo creato un programma C chiamato SonarWrapperBCR.c che utilizzasse
            gli script python. Tuttavia, la chiamata di programmi esterni generava overhead e ne rallentava
            l'esecuzione. Quindi abbiamo deciso di creare un programma completamente in C che implementasse
            tutte le funzioni, ed implementare la possibilità di abilitare le varie feature tramite opzioni passate
            come argomenti del programma.

            <h3>Led</h3>

            <h3>Integration with WasteService</h3>
            + add entry to build.gradle

            <h2 id="Command-Runner">Sprint 2.4: Command Runner</h2>

            <h2 id="Extensions">Sprint 2 Extensions</h2>
            <h3>RadarSystem22: Radar GUI</h3>
            Since our software house already developed a project capable of showing sonar
            information in a fancy way, we considered its usage and analyzed if there was
            a way to adapt it and include it in our Waste Service project.
            <br/><br/>

            The <a href="https://github.com/mikyll/righimichele/tree/master/iss2022/RadarSystem22/radarGUI"><ksi>Radar GUI</ksi></a>
            project consists of an application able to display elaborated information of 
            detected obstacles, with a sonar-like graphical interface:

            a line the length of the radius constantly rotates with its pivot in the
            center of the screen, <b><i>simulating a sonar</i></b>. Detected obstacles (with their
            distance and angle) are stored in a queue and, if the detected obstacle 
            distance is within the bounds of interest, as soon as the line encounters
            the point, the application display

            <center>
                <img width="50%" src="../imgs/radarGUI.gif"/>
            </center>

            The Radar GUI project is completely written in C with SDL2 and 
            includes an interface to ease the networking communication, using UDP and 
            TCP.
            <br/><br/>

            Example usage: run the radarGUI on a computer, and a client on a Raspberry Pi,
            which detects obstacles with the sonar module, and sends the data by using the
            networking interface.

            <consideration>
                <b>Consideration</b>: our first idea was to enhance the Raspberry Pi node 
                by attaching to the device an LCD touchscreen display with 3.5" size, so that
                it <b>would show the obstacle/distances detected by the sonar already on the device</b>. 
                <br/>
                We also already had the LCD display component.
            </consideration>
            
            <problem>Raspberry Device PINs</problem>
            <b>Problem</b>: what prevent us from pursuing this enhancement, was the fact that
            that particular display needs to be attached to the first 26 pins of the Raspberry Pi,
            including the 5V power supply one. That's an issue since the HC-SR04, which is a <i><b>requirement</b></i>
            needs it too.
            
            <solution>
                <b>Decision</b>: we decided <ksi>not to implement that extension</ksi>, due to the time and
                it would have required to search for and develop a workaround.
            </solution>
            
            <h2 id="Deployment">Deployment</h2>
            Until now we deployed our sistem using the Gradle JAR plugin.
            
            However, a better approach would be to use the distribution plugin:
            https://docs.gradle.org/current/userguide/distribution_plugin.html

            which allows


            <h2 id="Demo">Sprint2 Demo</h2>
            In order to run demo components we need:
            [...]
            
            <h4>Setup Remote Communications</h4>
            <highlight1>To setup remote communication refer to this: link.</highlight1>
        
        </div>

    </body>

</html>
