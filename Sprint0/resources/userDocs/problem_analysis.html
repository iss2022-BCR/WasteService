<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Sprint0</title>
        <link rel="stylesheet" type="text/css" href="../styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="../styles/main.css">
        <link rel="stylesheet" type="text/css" href="../styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="../styles/table.css">
        <link rel="stylesheet" type="text/css" href="../styles/code.css">
        <script type="text/javascript" src="../scripts/myScripts.js"></script>
    </head>

    <body onload="loadNav();">
        <div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
        <div id="sidenav" class="sidenav">
            <a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
            <a href="../../index.html">Index</a>
            <a href="final_theme.html">Final Theme</a>
            <a href="requirement_analysis.html">Requirement<br/>Analysis</a>
            <a class="selected" href="problem_analysis.html">Problem Analysis</a>
            <div class="sidenavSection">
                <a href="#Service-Area">Service Area</a>
                <div class="sidenavSubSection">
                    <a href="#Relevant-Positions">Relevant Positions</a>
                </div>
                <a href="#Requirements-Formalization">Requirements<br/>Formalization</a>
                <div class="sidenavSubSection">
                    <a href="#Entities">Entities</a>
                    <a href="#Data">Data</a>
                    <a href="#Messages">Messages</a>
                </div>
                <a href="#Models">Models</a>
                <div class="sidenavSubSection">
                    <a href="#Why-QAK">Why QAK</a>
                    <a href="#System-QAK-Model">System QAK Model</a>
                </div>
                <a href="#Logical-Architecture">Logical Architecture</a>
                <a href="#Test-Plans">Test Plans</a>
            </div>
            <a href="conclusions.html">Conclusions</a>
            <a href="team.html">Team</a>
            <p style="height: 100px; visibility: hidden"></p><!-- tmp -->
        </div>

        <div id="main">
            <h1 align="center">Problem Analysis</h1>
            <h2 id="Service-Area">Service Area</h2>
            <b>Problem</b>: we need a proper <i>representation</i> of the service area to optimally move and monitor the transport trolley.<br/>
            <b>Solution</b>: <ksi>2x2 matrix</ksi>, where each element represents a different position, starting from the top-left corner.<br/>
            <b>Reasons</b>:
            <ul>
                <li>
                    Since the HOME is the top-left corner, it's more intuitive to represent it as the
                    first element of the matrix, which is the [0,0] element. 
                </li>
                <li>
                    We can associate a <b>cartesian coordinate system</b> to the matrix with the origin in the
                    top-left corner and RD as unit. That might make things easier later on, if we will
                    need to implement a graphical representation of the transport trolley state 
                    (for example in WasteServiceStatusGUI).
                    This because almost every software, library, framework or API, start drawing from
                    the top-left corner to the bottom-right one.
                </li>
            </ul>

            <div class="image-container">
                <img id="map" class="base-image" width="100%" src="../../resources/imgs/modello_stanza_v4.png"/>
                <img id="map-legend" class="overlay-image1" width="100%" src="../../resources/imgs/modello_stanza_solo_scritte.png"/>
                <img id="map-coordinates" class="overlay-image2" width="100%" src="../../resources/imgs/modello_stanza_solo_coordinate.png"/>    
            </div>
            <input type="checkbox" onclick="showOverlay(this, 'map-legend');" checked>Show the legend</input><br/>
            <input type="checkbox" onclick="showOverlay(this, 'map-coordinates');" checked>Show the coordinate system</input>
            <br/>
            <h3 id="Relevant-Positions">Relevant Positions</h3>
            The matrix number of rows and columns depend on RD (which is the size of the DDR robot),
            therefore for the moment we assume to have an M x N matrix, i.e. with respectively M rows (x axis)
            and N columns (y axis).<br/>
            <div class="remark">
                The relevant positions are:
                <ul>
                    <li>[0,0] = <ks>HOME</ks></li>
                    <li>from [0,M] to [4,M] = <ks>INDOOR</ks></li>
                    <li>from [N,0] to [N,4] = <ks>GLASSBOX</ks></li>
                    <li>from [N,M-4] to [N,M] = <ks>PLASTICBOX</ks></li>
                </ul>
            </div>

            <h2 id="Requirements-Formalization">Requirements Formalization</h2>
            <h3 id="Entities">Entities</h3>
            <table class="dictionary">
                <tr>
                    <th>Entity</th>
                    <th>Activity</th>
                    <th>Type</th>
                    <th>Description/Behaviour</th>
                </tr>
                <tr>
                    <td>wasteTruck</td>
                    <td>Reactive</td>
                    <td><highlight1>(Test) Actor</highlight1></td>
                    <td>
                        Entity that approaches the INDOOR of the service area to dump some wasteLoad.
                        It's represented as an actor for testing/simulation purposes: it sends dummy 
                        requests once in a while.
                    </td>
                </tr>
                <tr>
                    <td>wasteService</td>
                    <td>Proactive&nbsp& Reactive</td>
                    <td>Actor</td>
                    <td>
                        Handles the wasteTruck requests and manages the transport trolley actions.
                        It also sends updates to the wasteServiceStatusGUI and to the alarmDevice.
                    </td>
                </tr>
                <tr>
                    <td><emn>basicRobot</emn></td>
                    <td>Reactive</td>
                    <td>Actor</td>
                    <td>Entity that receives commands from the transportTrolley and drives the DDR robot.</td>
                </tr>
                <tr>
                    <td>transportTrolley</td>
                    <td>Proactive&nbsp& Reactive</td>
                    <td>Actor</td>
                    <td>
                        Main entity of the wasteService system, which moves within the service area and
                        performs the deposit actions.
                    </td>
                </tr>
                <tr>
                    <td>wasteService-<br/>StatusGUI</td>
                    <td>Reactive</td>
                    <td><highlight1>Actor</highlight1></td>
                    <td>
                        Entity that receives data from the wasteService and updates a GUI,
                        used to monitor the status of the service area.
                        We model it as an actor beacuse it processes messages one by one and
                        updates the GUI accordingly.
                    </td>
                </tr>
                <tr>
                    <td>alarmDevice</td>
                    <td>Proactive</td>
                    <td><highlight1>Actor</highlight1></td>
                    <td>
                        Entity, which is part of a smart device, that sends a message to the
                        wasteService when it detects the presence of an obstacle.
                        We formalize the alarmDevice as an actor because it has its own autonomous
                        flow of control, and sends messages to wasteService.
                    </td>
                </tr>
                <tr>
                    <td>warningDevice</td>
                    <td>Reactive</td>
                    <td><highlight1>Actor</highlight1></td>
                    <td>
                        Entity, which is part of a smart device, used to monitor the state of the trolley,
                        We model it as an actor beacuse it processes messages one by one and
                        updates the Led state accordingly.
                    </td>
                </tr>
            </table>

            <h3 id="Data">Data</h3>
            We had chosen <ksi>Kotlin</ksi> because it provides the built-in syntax necessary
            to declare our model elements and can be included in QAK code.<br/>
            <table class="dictionary">
                <tr>
                    <th>Data</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>truckLoad</td>
                    <td>Floating point variable</td>
                    <td>
                        Indicates the <b>weight</b> of the waste that the truck wants <b>to dump</b>.
                        Since the weight is expressed in kg, we have to use decimal too.
                        <pre>
                            val truckLoad : Float
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>wasteLoad</td>
                    <td>Floating point variable</td>
                    <td>
                        Indicates the <b>weight</b> of waste that the transport trolley is going <b>to deposit</b>.
                        <pre>
                            val wasteLoad : Float
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>WasteType</td>
                    <td>Enumerative</td>
                    <td>
                        Indicates the <b>type of waste</b> to deposit.
                        <pre>
                            enum class WasteType { PLASTIC, GLASS }
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>PICKUP_TIME</td>
                    <td>Integer constant</td>
                    <td>
                        <b>Time</b> in seconds, known in advance, it takes the transport trolley to <b>pick up</b> the waste.
                        <pre>
                            const val PICKUP_TIME : Int
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>MAXPB</td>
                    <td>Floating point constant</td>
                    <td>
                        Maximum waste <b>capacity</b> that the <b>PlasticBox</b> can store.
                        <pre>
                            const val MAXPB : Float
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>MAXGB</td>
                    <td>Floating point constant</td>
                    <td>
                        Maximum waste <b>capacity</b> that the <b>GlassBox</b> can store.
                        <pre>
                            const val MAXGB : Float
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>RD</td>
                    <td>Integer constant</td>
                    <td>
                        <b>Length</b> of the <b>transport trolley</b>.
                        <pre>
                            const val RD : Int
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td>DLIMT</td>
                    <td>Floating point constant</td>
                    <td>
                        <b>Limit distance</b> beyond which the alarm is activated.
                        <pre>
                            const val DLIMT : Float
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>Box</emn></td>
                    <td>Enumerative</td>
                    <td>
                        <b>Unique area, within serviceArea</b>, of RD width. A Box represents a position where the transport trolley could be at a certain time.
                        <pre>
                            enum class Box { EMPTY, HOME, TRANSPORT_TROLLEY, INDOOR, PLASTICBOX, GLASSBOX }
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>serviceArea</emn></td>
                    <td>2 dimensional
                        matrix of Box-es</td>
                    <td>
                        <b>Area within which the transport trolley can move</b>, made by N x M Boxes.
                        <pre>
                            val serviceArea = Array(N) { IntArray(M) }
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>ROWS</emn></td>
                    <td>Integer constant</td>
                    <td>
                        Number of <b>rows of the service area</b> matrix.
                        <pre>
                            const val ROWS : Int
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>COLUMNS</emn></td>
                    <td>Integer constant</td>
                    <td>
                        Number of <b>columns of the service area</b> matrix.
                        <pre>
                            const val COLUMNS : Int
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>TTState</emn></td>
                    <td>Enumerative</td>
                    <td>
                        All the <b>possible states</b> of the transport trolley.
                        <pre>
                            enum class TTState { IDLE, MOVING, PICKINGUP, STORING, STOPPED }
                        </pre>
                    </td>
                </tr>
                <tr>
                    <td><emn>LedState</emn></td>
                    <td>Enumerative</td>
                    <td>
                        All the <b>possible states</b> of the Led.
                        <pre>
                            enum class LedState { OFF, ON, BLINKING }
                        </pre>
                    </td>
                </tr>
            </table>

            <h3 id="Messages">Messages</h3>
            <highlight2>Riguardare</highlight2>
            <table class="dictionary">
                <tr>
                    <th>Message</th>
                    <th>Type</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>storeLoad</td>
                    <td>Request</td>
                    <td>
                        Message sent from the truck driver to the WasteService through a smart device,
                        to ask if it can dump TruckLoad kg of waste.
                    </td>
                </tr>
                <tr>
                    <td>loadAccepted</td>
                    <td>Response</td>
                    <td>
                        Message received from the WasteService,
                        that means there is enough space for the waste to be deposited.
                        Once this message is received, the truck waits T seconds (prefixed pickup time),
                        then it leaves and frees the INDOOR.
                    </td>
                </tr>
                <tr>
                    <td>loadRejected</td>
                    <td>Response</td>
                    <td>
                        Message received from the WasteService,
                        that means there is NOT enough space for the waste to be deposited.
                        When the truck receives this messages, it leaves and freed the INDOOR immediately.
                    </td>
                </tr>
                <tr>
                    <td>stop</td>
                    <td>Dispatch</td>
                    <td>
                        Alarm message, sent from the RaspberryPi to the WasteService, to stop the transport trolley activity.
                    </td>
                </tr>
                <tr>
                    <td>resume</td>
                    <td>Dispatch</td>
                    <td>
                        Message, sent from the RaspberryPi to the WasteService, to resume the transport trolley activity.
                    </td>
                </tr>
                <!--<tr>
                    <td>start</td>
                    <td>Dispatch</td>
                    <td>
                        Message the user of WasteService can send to the system, to initialize it.
                    </td>
                </tr>-->
                <tr>
                    <td><emn>serviceArea-<br/>State</emn></td>
                    <td>Dispatch</td>
                    <td>
                        Message, sent from the WasteService to the WasteServiceStatusGUI, which contains the transport trolley current state.
                    </td>
                </tr>
                <tr>
                    <td><emn>ledState</emn></td>
                    <td>Dispatch</td>
                    <td>
                        Message, sent from the WasteService to the WasteServiceStatusGUI, which contains the state the Led will have to enter.
                    </td>
                </tr>
            </table>
            
            <h2 id="Models">Models</h2>
            <h3 id="Why-QAK">Why QAK</h3>
            <b>Problem</b>: we need to fill the abstraction gap related to the concept of <i>service</i>.<br/>
            <b>Solution</b>: <ksi>QAK meta-modeling language</ksi>.<br/>
            <b>Reasons</b>:
            <ul>
                <li>
                    It's was implemented entirely created whitin our
                    <a href="https://github.com/anatali/issLab2022">software house</a>, which makes
                    it easier to get information and support from the actual creator of the language. 
                </li>
                <li>
                    It provides a way to represent concepts related to services, such as
                    request, response, dispatch, etc.; while other general-purpose languages
                    would need external libraries (e.g. Java would need some kind of JAR to
                    implement Actors), frameworks or resources to do the same.
                </li>
                <li>
                    It allows you to create executable models, directly from the language,
                    which capture the salient aspects of the requirements or problems.
                </li>
                <li>
                    Our software house already has some project and components we could
                    exploit and use.
                </li>
            </ul>
            <highlight2>
                <a href="">QAK cheatsheet</a><br/>
                <a href="">QAK documentation</a><br/>
                QAK is a custom (meta)modeling language documentation
            </highlight2>
            <h3 id="System-QAK-Model">System QAK Model</h3>
            File: <a href="../models/demo_system_overview_v1.txt">demo_system_overview.qak</a>

            <pre style="white-space: pre-wrap;">
System demo_system_overview

// CONTEXTS ===================================================================
Context ctx_wasteservice	ip [host="localhost" port=11800]
Context ctx_monitor			ip [host="localhost" port=11801]
Context ctx_alarm			ip [host="localhost" port=11802]
Context ctx_test			ip [host="localhost" port=11803]

// MESSAGES ===================================================================
// truckdriver <-> wasteservice
Request storerequest :		storerequest( WasteType, TruckLoad )
Reply loadaccept :			loadaccept()
Reply loadrejected :		loadrejected()

// rasp <-> wasteservice
Event stopevent :			stopevent()
Event resumeevent :			resumeevent()
Dispatch setled :			setled( STATE )

// radar -> rasp ??
Event sonardata :			sonar( Data )

// trolley -> truckdriver
Event pickupend :			pickupend()

// trolley -> ??
Event depositend :			depositend()

// wasteservice -> trolley
Dispatch loadwaiting :		loadwaiting( WasteType )

// wasteservice -> monitor
Dispatch servicestate :		servicestate(TrolleyState, TrolleyPosition, PlasticWeight, GlassWeight, LedState)

// ACTORS =====================================================================
QActor wasteservice context ctx_wasteservice {
    
    State state_init initial {
        // init (reset system)
        [#
            var currentPlastic =	0.0F
            var currentGlass =		0.0F
            // reset trolley position to Home
        #]
        println("[WasteService] ")
    }
    Goto state_idle
    
    State state_idle {
        // wait for messages:
    }
    Transition t0	whenMsg storerequest	->	state_handle_store
                    whenEvent stopevent 	-> 	state_hande_stop
                    whenEvent resumeevent 	-> 	state_handle_resume
    // begin to accept requests

    State state_handle_deposit {
        // check if there is enough space
        // yes: send accept and make the trolley do the deposit action
        if [# utils.checkEnoughSpace(WasteType, TruckLoad) #] {
            replyTo depositrequest with loadaccept : loadaccept()
            
            forward trasporttrolley -m loadwaiting : loadwaiting()
        }
        // no: send rejected
        else {
            replyTo depositrequest with loadrejected : loadrejected()
            // trolley stai a casa porcodio che cazzo fai c'è il covid
        }
    }
    Goto state_idle

    // DA DEFINIRE:	il comando per settare il led forse è meglio sul raspberry
    // 				ma bisogna capire se è meglio comunicare che il robot stia
    //				lavorando al rasp oppure far fare tutto al WasteService
    State state_handle_stop {
        // utils.trolley.sendAction(INTERRUPT)
        // utils.rasp.setLed(ON)
    }
    Goto state_idle

    State state_handle_resume {
        // var wasDoingTask = utils.trolley.sendAction(RESUME)
        if [# wasDoingTask #]{
            // utils.rasp.setLed(BLINK)
        }else{
            // utils.rasp.setLed(OFF)
        }
    }
    Goto state_idle
}

QActor transporttrolley context ctx_wasteservice {
    State state_init initial {
        [#
            var currWaste = ""	
        #]
    }
    Goto state_idle

    State state_idle {
        // Just chilling...
    }
    Transition t0	whenEvent	emergencyinterrupt	->	state_interrupt_handle	// non sono troppo sicuro di questi due
                    whenEvent	emergencyresume		->	state_resume_handle
                    whenMsg		loadwaiting			->	state_loadwaiting_handle
    
    // goes to INDOOR
    State state_loadwaiting_handle {
        // ormai leggere il payload di un messaggio equivale a rendere il codice confuso perchè mi dimentico di aggiungere "msg."

        // utils.trolley.moveTo(INDOOR)
        [# currWaste = WasteType #]
    }
    Goto state_pickup
    
    // unload the truck
    // (separare il movimento dal pickup mi sembrava un po' più sensato di avere tutto insieme, ma potrebbe essere una cazzata)
    State state_pickup {
        // utils.trolley.pickup()

        emit pickupend : pickupend()
    }
    Goto state_deposit

    // deposit the load
    State state_deposit {
        if [# currLoad == 'plastic' #]{
            // utils.trolley.moveTo(PLASTIC)
        }else{
            // utils.trolley.moveTo(GLASS)
        }

        delay 200	// simula il tempo di deposito (?)

        emit depositend : depositend()	// potrebbe servire, al momento non so per cosa però
    }
    Transition t1	whenTimer	1000		->	state_gohome				// prima di tornare a casa, attende nuovi depositi
                    whenMsg		loadwaiting	->	state_loadwaiting_handle	
    
    // better a lot of simple states than fewer more complex
    State state_gohome {
        // utils.trolley.moveTo(HOME)
    }
    Goto state_idle

    // La soluzione precedente non tiene conto di eventuali richieste che arrivano durante il tragitto verso casa
}

QActor wasteservicestatusgui context ctx_monitor {
    // initial state, reset gui status (idk what it has, so just a random func)
    State state_init initial {
        // utils.gui.reset()
    }
    Goto state_idle

    // waiting for updates
    State state_idle {
        // Really wished I got that Netflix subscription...
    }
    Transition t0 	whenMsg servicestate -> state_update_handle

    State state_update_handle {
        // still no idea di come leggere i dati di un messaggio
        // still no idea di come settare lo stato di questa maledetta gui
        // no thoughts, only functions
        // utils.gui.setState(TrolleyState, TrolleyPosition, PlasticWeight, GlassWeight, LedState)
    }
    Goto state_idle
}

QActor raspdevice context ctx_alarm {
    // initial state, DLIMT hardcoded atm
    State state_init initial {
        [#
            var DLIMT = 		30.0F
            var LedStatus =		"OFF"
            var stoppped = 		false	// potrebbe essere evitato controllando lo stato del Led
                                        // ma lo preferisco per leggibilità del codice
        #]
    }
    Goto state_idle

    // waiting for data from sonar
    State state_idle {
        // too much chilling in here, give me a jacket...
    }
    Transition t0	whenEvent	sonardata	->	state_sonar_handle
                    whenMsg		setled		->	state_led_handle	// non implementato al momento, aspettando discussione
    
    State state_sonar_handle {
        // non c'è scritto da nessuna parte come leggere i dati del payload
        // potrei piangere non ironicamente
        if [# DATA >= DLIMT && !stopped #]{		// è giusto che il sonar debba farsi il problema se il robot è fermo?
            emit stopevent : stopevent()
            [# stopped = true #]
        }

        if [# DATA < DLIMT && stopped #]{
            emit resumeevent : resumeevent()
            [# stopped = false #]
        }
    }
    Goto state_idle
}

QActor testdriver context ctx_test {
    // initialize a random load and does a request
    State state_init initial{
        [#
            var WasteType = rand('plastic', 'glass')	// rand() non penso esista
            var TruckLoad = rand(1, 15)
        #]

        request wasteservice -m storerequest : storerequest( WasteType, TruckLoad )
    }
    Transition t0	whenMsg	loadaccept		->	state_accept_handle
                    whenMsg	loadrejected	->	state_end				// il mio lavoro qui è finito
    
    State state_accept_handle {
        // not sure to what happens here
        // I think it just wait for a pickup action to end
    }
    Transition t1	whenEvent	pickupend	->	state_end

    State state_end {
        // see you, space waste truck!
    }
    // Goto futuro incerto, teoricamente il wastetruck qui ha finito di fare le cose utili
}

// Additional actor for test/simulation purposes only
            </pre>

            <h2 id="Logical-Architecture">Logical Architecture</h2>
            Drawing with legend (NB: il QAK fornisce un diagramma da inserire qui)

            <h2>Diagrams</h2>
            UML (forse meglio metterli negli sprint successivi)

            <h2 id="Test-Plans">Test Plans</h2>
            Executable Models

        </div>

    </body>

</html>