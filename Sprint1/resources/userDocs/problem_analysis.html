<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
    <head>
        <title>Sprint1</title>
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/templateISS.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/main.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/navbar.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/table.css">
        <link rel="stylesheet" type="text/css" href="../../../commons/resources/styles/code.css">
        <script type="text/javascript" src="../../../commons/resources/scripts/myScripts.js"></script>
    </head>

    <body onload="loadNav();">
        <div id="openButton" class="openButton" onclick="openNav(true)">&#9776; Menu</div>
        <div id="sidenav" class="sidenav">
            <a class="closeButton" href="javascript:void(0)" onclick="closeNav(true)">&times;</a>
            <a class="sprint" href="../../../Sprint0/index.html">Sprint0</a>
            <a id="currentSprint" class="sprint" href="#">&#8211;&#8212; Sprint1 &#8212;&#8211;</a>
            <a href="../../index.html">Index</a>
            <a href="final_theme.html">Final Theme</a>
            <a href="requirement_analysis.html">Requirement<br/>Analysis</a>
            <a class="selected" href="problem_analysis.html">Problem Analysis</a>
            <div class="sidenavSection">
                <a href="#Core-Business-Software">Core-Business<br/>Software</a>
                <div class="sidenavSubSection">
                    <a href="#Smart-Device">Smart Device</a>
                    <a href="#Waste-Service">Waste Service</a>
                    <a href="#Transport-Trolley-and-DDR-Robot">Transport Trolley<br/>and DDR Robot</a>
                </div>
                <a href="#Interactions">Interactions</a>
                <div class="sidenavSubSection">
                    <a href="#Smart-Device-Waste-Service">Smart Device &harr;<br/>Waste Service</a>
                    <a href="#Waste-Service-Transport-Trolley">Waste Service &harr;<br/>Transport Trolley</a>
                    <a href="#Transport-Trolley-DDR-Robot">Transport Trolley &harr;<br/>DDR Robot</a>
                </div>
                <a href="#Logical-Architecture">Logical Architecture</a>
                <a href="#Test-Plans">Test Plans</a>
            </div>
            <a href="project.html">Project</a>
            <a href="test_plans.html">Test Plans</a>
            <a href="conclusions.html">Conclusions</a>
            <a href="team.html">Team</a>
            <p class="separator">&mdash;&mdash;&mdash;&ndash;&ndash;&mdash;&mdash;&mdash;</p>
            <a class="sprint" href="../../../Sprint2/index.html">Sprint2</a>
            <a class="sprint" href="../../../Sprint3/index.html">Sprint3</a>
            <bottom-spacer/>
        </div>

        <div id="main">
            <h1 align="center">Problem Analysis</h1>
            
            <highlight3>
                moveTo:
                - scrivere perché scegliamo request: per ora va bene request, ma quando dovremo fare la stop/resume, sarà necessario poter interrompere una action, quindi forse servirà un dispatcho. <br/>
                - definire meglio "location" (posizione, come casella - coordinate) e spiegare perché questa scelta.
                <br/>
                <br/>
                
                Utile(?): glassbox [1,2,3,4] per indicare quale casella del glassbox (dare spiegazione smanettona sul perché si accumula la spazzatura in un punto ehehe)
                
                Spiegare perché origine del piano cartesiano sta in alto a sinistra
            </highlight3>

            <br/><br/>

            <highlight2>
                Come formalizzare i messaggi

                formato: JSON, perché? -> semplice, leggero, compatto, facile da leggere, ci sono numerosi parser (tra cui Gson, di Google)
                + layer di sicurezza? Eventuale Sprint4 tratterà questo argomento.
            </highlight2>
            <br/><br/>

            <h2 id="Core-Business-Software">Core-Business Software</h2>
            <highlight1>Paradigma ad attori</highlight1>
            Perché scegliamo il paradigma ad attori?
            motivazioni + QAK

            <br/>
            Spiegare le funzioni dei vari attori (magari inserire una tabella)
            <ul>
                <li>Il waste service gestisce le richieste. Gestisce le operazioni che il transport trolley deve eseguire:
                    - pickup
                    - deposit(smth)
                    - 

                </li>
                <li>
                    The transport trolley doesn't know what's a container or how much waste he's moving,
                    he just executes commands (it's an actuator), with a predefined behaviour:
                    - deposit(smth) -> go to indoor, pickup, move to deposit the material, dump, go home 
                    sync or async, blocking or not blocking? Could be sync, but there are 2 problems:
                    1) could arrive a new request while it's going home;
                    2) could be stopped (requirement not yet to be analyzed -> sprint2)
                </li>
                
            </ul>
            <br/>
            <highlight1>Spiegare perché usiamo il paradigma ad attori; Spiegare quanti e dove collocare i vari attori nei nodi (tabella alla fine?)</highlight1>
            

            <h3 id="Smart-Device">Smart Device</h3>
            <!--<problem>Smart Device Technology</problem>
            <b>Problem</b>: implementation of an application to test the interaction between the truck driver and the waste service.<br/>
            <solution>
                <b>Solution</b>: <ksi>Flutter application</ksi>.<br/>
                <b>Reasons</b>:
                <ul>
                    <li>Google framework released recently (end of 2018) and with great and active support.</li>
                    <li>Based on Dart language (also developed by Google), an object-oriented language with a syntax much similiar to Java.</li>
                    <li>
                        Simple to use and learn, since the documentation is full of examples and tutorials,
                        which makes it easier to develop prototypes and production applications, and it's becoming
                        more and more popular lately.
                    </li>
                    <li>Material design: everything is a Widget, which make it perfect when it comes to apply OOP principles and design patterns.</li>
                    <li>Cross-platform: it allows to write one codebase and build it for many platforms (web, desktop, <b><i>mobile</i></b>).</li>
                    <li>Hot reload allows to see changes directly while using the application, without having to rebuild it entirely.</li>
                    <li>
                        Extremely handy: we can show off a <i>more practical demo</i> to the customer, since we can give him
                        an application that he can <b><i>install and try directly on his smartphone</i></b>.
                    </li>
                </ul>
            </solution>
            <center>
                <a href="https://flutter.dev/"><img width="90%" alt="Flutter: Build apps for any screen." title="Flutter: Build apps for any screen." src="../imgs/Flutter2.png"/></a>
                <br/>
                <b><i>Flutter: Build apps for any screen</i>.</b>
            </center>-->
            
            
            <h3 id="Waste-Service">Waste Service</h3>
            The customer requirements don't specify priority rules regarding the truck requrests,
            therefore, they'll be served in order of arrival.

            We decide to send a <code>load_rejected</code> even if the <code>store_request</code>
            contains a invalid data:
            <ul>
                <li>Not properly formatted according to the JSON object.</li>
                <li>Negative or too big WasteLoad.</li>
                <li>WasteType not present in the Service Area.</li>
            </ul>   

            <problem>Service Area Representation</problem>
            <b>Problem</b>: we need a proper <i>representation</i> of the service area to optimally move and monitor the transport trolley.
            <br/>
            <solution>
                <b>Solution</b>: 
                <ul>
                    <li>
                        Waste Service side: use a descriptive model to indicate the main relevant position (<red>HOME</red>, <cyan>INDOOR</cyan>, <green>GLASSBOX</green>, <yellow>PLASTICBOX</yellow>).
                    </li>
                    <li>
                        Transport Trolley side: Use a <ksi>2x2 matrix</ksi>, where each element represents a different position, starting from the top-left corner.
                    </li>
                </ul>
                <b>Reasons</b>:
                <ul>
                    <li>
                        Since the HOME is the top-left corner, it's more intuitive to represent it as the
                        first element of the matrix, which is the [0,0] element. 
                    </li>
                    <li>
                        We can associate a <b>cartesian coordinate system</b> to the matrix with the origin in the
                        top-left corner and RD as unit. That might make things <i>easier later on</i>, if we will
                        need to implement a graphical representation of the transport trolley state 
                        (for example in WasteServiceStatusGUI).
                        This because almost every software, library, framework or API, start drawing from
                        the top-left corner to the bottom-right one.
                    </li>
                    <li>
                        <highlight2>We could use the software provided by the customer,
                        such as the mapper to obtain a representation of the room,
                        and the path executor to make the robot move along a path.</highlight2>
                    </li>
                </ul>
            </solution>

            <div class="image-container">
                <img id="map" class="base-image" width="100%" src="../../resources/imgs/modello_stanza_v4.png"/>
                <img id="map-legend" class="overlay-image1" width="100%" src="../../resources/imgs/modello_stanza_solo_scritte.png"/>
                <img id="map-coordinates" class="overlay-image2" width="100%" src="../../resources/imgs/modello_stanza_solo_coordinate.png"/>    
            </div>
            <input type="checkbox" onclick="showOverlay(this, 'map-legend');" checked>Show the legend</input><br/>
            <input type="checkbox" onclick="showOverlay(this, 'map-coordinates');" checked>Show the coordinate system</input>
            <br/>
            <h5 id="Relevant-Positions">Relevant Positions</h5>
            The matrix number of rows and columns depend on RD (which is the size of the DDR robot),
            therefore for the moment we assume to have an M x N matrix, i.e. with respectively M rows (x axis)
            and N columns (y axis).<br/>
            <div class="remark">
                The relevant positions are:
                <ul>
                    <li>[0,0] = <red>HOME</red></li>
                    <li>from [0,M] to [4,M] = <cyan>INDOOR</cyan></li>
                    <li>from [N,0] to [N,4] = <green>GLASSBOX</green></li>
                    <li>from [N,M-4] to [N,M] = <yellow>PLASTICBOX</yellow></li>
                </ul>
            </div>

            Come otteniamo la rappresentazione della mappa? Possiamo utilizzare unibo.mapper (link al progetto),
            che fornisce un modello QAK eseguibile, in particolare:
            <br/>
            mapperqak22.qak
            <br/>
            Eseguire unibo.mapperQak22\src\it\unibo\ctxmapemptyroom22\MainCtxmapperqak22.kt
            <br/>
            Che salva la mappa in <a href="">mapRoomEmpty.txt</a>

            <h3 id="Transport-Trolley-and-DDR-Robot">Transport Trolley and DDR Robot</h3>
            <problem>Robot Concepts</problem>
            <b>Problem</b>: what is the Transport Trolley and what is the DDR Robot?
            <solution>
                <b>Considerations</b>: The DDR Robot is the final endpoint of the core-business chain,
                the entity that performs the deposit actions and dumps the waste into the containers.
                Therefore we can think of it as the actual "robot", which might be real or virtual (e.g. for
                simulation purposes).
                <br/>
                On the other hand, the Transport Trolley is a more abstract concept, which encloses the logic
                and controls the DDR Robot.

                <table class="dictionary">
                    <tr>
                        <td style="color: black">Transport Trolley</td>
                        <td>high-level control unit.</td>
                    </tr>
                    <tr>
                        <td style="color: black">DDR Robot</td>
                        <td>low-level technology agent.</td>
                    </tr>
                </table>

                <br/>
                <b>Solution</b>: we can use the BasicRobot QAK actor, provided by the customer together with unibo.basicRobot22 project,
                to have both a <ksi>virtual environment</ksi> to simulate the DDR Robot (WEnv), and a <ksi>virtual interface</ksi> to communicate with it (VirtualRobot).
                <br/><br/>
                <center>
                    <img width="60%" alt="WEnv" title="WEnv (Scene)" src="../imgs/WEnv.png"/>
                    <br/>
                    <b>WEnv (Scene)</b>
                </center>
                <br/>
                <b>Reasons</b>:
                <ul>
                    <li>we reuse code that's already implemented</li>
                    <li>
                        basicRobot is built following the actors paradigm (and QAK meta-modeling lang),
                        so it's easy to integrate it with the rest of the project
                    </li>
                </ul>
            </solution>
            <b>Alternatives</b>:


            <problem>Robot Movement</problem>
            
            We might use the software provided by the customer: Applicazioni22
            The path executor wants ..., <highlight3>How to find the path to execute?</highlight3>
            <br/>

            We assume that the deposit action cannot fail and the trolley cannot be stopped, for the moment.
            However, since we know in the next sprint we'll implement the stop/resume mechanics, we decide to model the interaction in an asynchronous way.
            
            WEnv -> Virtual Enviromnent fornito dal committente, spieghiamo perché usiamo questo

            <h2 id="Interactions">Interactions</h2>
            <problem>Messages format</problem>
            <b>Problem</b>: What format to use for messages
            <solution>
                <b>Solution</b>: Prolog terms syntax
                <br/>
                <b>Reasons</b>: it's the message format of the QAK (meta-)modeleing language
            </solution>
            <b>Alternatives</b>: JSON object format. However, we would still need to parse that 

            <h3 id="Messages">Core-Business Messages List</h3>
            <table class="dictionary">
                <tr>
                    <th>Message</th>
                    <th>Type</th>
                    <th>Sender</th>
                    <th>Receiver</th>
                    <th>Description</th>
                </tr>
                <tr>
                    <td>storeRequest</td>
                    <td>Request</td>
                    <td>SmartDevice</td>
                    <td>WasteService</td>
                    <td>
                        Ask if <ks><code>truckLoad</code></ks> kg of <ks><code>wasteType</code></ks> can be dumped to the waste service.
                    </td>
                </tr>
            </table>

            <h3 id="Smart-Device-Waste-Service">Smart Device &harr; Waste Service</h3>
            
            <problem>Waste Types</problem>
            <b>Problem</b>: how does the smart device know which types of waste can be dumped to the waste service?
            <br/>
            <b>Possible solution</b>: hard-code the types into the Smart Device.
            <br/>
            <b>Considerations</b>:
            <ol>
                <li>
                    <b>Pros</b>: this is the easiest solution to implement, since they can be just implemented as a list or an enumerative.
                </li>
                <li>
                    <b>Cons</b>: not scalable, since it doesn't allow the Waste Service to have different waste containers but
                    the ones initially specified by the customer in the requirements.
                </li>
            </ol>
            <solution>
                <b>Better solution</b>: <ksi>ask the Waste Service for the allowed waste types</ksi>, along with the
                connection message, and update the Smart Device list to be chosen.
                <br/>
                <b>Reasons</b>:
                <ul>
                    <li>
                        Much <b><i>more scalable</i></b>, since the list can eventually be extended in the future, all from the Waste Service side,
                        without having to distribute or push updates to the Smart Device. 
                    </li>
                    <li>
                        It introduces a layer of complexity, since the communication between the Smart Device and the Waste Service requires
                        at least <b><i>one more message</i></b>, but the tradeoff gives more advantages than the disadvantages, and the result can be
                        achieved by introducing a specific Actor that deals with the types providing. 
                    </li>
                </ul>
            </solution>
            <center><img width="90%" src="../diagrams/sprint1_seq-SM-WS_v4.svg"/></center>
            
            <problem>Store Request Validation</problem>
            <b>Problem</b>: what happens if the user enter invalid parameters of a store request? What happens if the waste service receives an invalid store request?
            <br/>
            <solution>
                <b>Solution</b>:
                <ul>
                    <li>
                        <ksi>client-side validation</ksi>: if the user enters invalid parameters for the
                        store request, the Smart Device displays an error and the request cannot be sent.
                    </li>
                    <li>
                        <ksi>server-side validation</ksi>: if an invalid store request is received, the Waste Service
                        replies with a loadrejected.
                    </li>
                </ul>
                <br/>
                <b>Reasons</b>:
                <ul>
                    <li>
                        That solution is the simplest to implement and the most efficient, since we invalid store
                        requests are just ignored, and the Waste Service doesn't spend computational time and resources
                        trying to understand the reason.
                    </li>
                    <li>
                        Since nothing (at the current state of the project) prevents a malicious user
                        to create and utilize a fake application which allows him to send invalid store requests,
                        a server-side validation, would make it impossible to break the system or have unexpected behaviour.
                    </li>
                </ul>
            </solution>
            <b>Eventual extra features</b>: having a security layer which allows only trusted devices to send store requests.
            This way, by knowing that the smart device will always be an original one (produced and deployed by our
            software house), we know for sure that a certain behaviour will be respected,
            therefore it won't be possible to send invalid store requests.
            
            <problem>Replies and Waste Truck Dismiss</problem>
            <b>Problem</b>: when is the reply sent and what message do we send? Do we introduce other messages apart from loadaccepted and loadrejected?
            How do we know immediately if the Waste Service can store the waste of a new request? How can we meet the requirement that
            the waste truck must be sent away as soon as possible?
            <br/>
            <b>Considerations</b>:
            <ul>
                <li>
                    The Waste Service might receive a new request while it is handling another one.
                </li>
                <li>The pickup action takes some time (a defined and known amount).</li>
                <li>
                    If the Smart Device sends a request while there is another deposit action
                    in progress, it must wait it to be completed.
                </li>
                <li>
                    If we're able to know if the load can be deposited as soon as we receive the request,
                    we could reply instantly, and therefore meet the <em>requirement</em> that the truck driver must
                    be sent away <i>as soon as possible</i>.
                </li>
            </ul>
            <solution>
                <b>Adopted solution</b>:
                <ul>
                    <li>
                        Send the <ksi>loadaccepted</ksi> reply <ksi>when the Waste Service completes the pickup action</ksi>.
                    </li>
                    <li>
                        Use <ksi>2 separate storage counters</ksi>: one that is updated as soon as the store request
                        is managed (incremented in the case of the loadaccepted), and a second one,
                        which is the actual current state of the storage, that is updated only when the
                        transport trolley completes a deposit action.
                    </li>
                    <li>
                        Use <ksi>2 separate actors</ksi>: the Waste Service that handles the requests, and the Transport Trolley
                        that performs the deposit actions.
                    </li>
                </ul>
                <br/>
                <b>Reasons</b>:
                <ul>
                    <li>
                        Send a reply only when the truck driver can be sent away.
                    </li>
                    <li>
                        It's simple to implement, since there are less messages to deal with, therefore less overhead.
                    </li>
                    <li>
                        Using <i>2 separate storage counters</i> allows us to send a reply to the
                        Smart Device as soon as possible, since we know if the waste can be stored at any time.
                    </li>
                    <li>
                        (Related to Sprint3 - Monitoring) we can update the GUI with a more time-accurated value
                        of how much space is left in each container.
                    </li>
                </ul>
            </solution>
            <alternative>
                <b>Alternative (better) solution</b>: introduce <i>one more message</i> '<code>pickup_completed</code>', that is sent by the Waste Service to
                the Smart Device and indicates that the pickup of the waste has been completed and the waste truck can leave the indoor.
                <br/>
                <b>Difficulties</b>: the QAK currently doesn't provide a way to send dispatches to aliens (i.e. the Smart Device), therefore we are not able to notify the Smart Device when the corresponding pickup action has been completed.
            </alternative>
            <b>Eventual extra features</b>:
            <ul>
                <li>
                    Send notification messages about the state (for example, 
                    'there is another deposit action in progress', or 'pickup action in progress')
                </li>
                <li>Send an estimate of the time to wait before the pickup (we might calculate the time of the previous requests)</li>
                <li>Allow the Smart Device to cancel a queued request.</li>
            </ul>
            
            
            <problem></problem>
            <b>Problem</b>: 
            <solution>
                <b>Solution</b>:
                <br/>
                <b>Reasons</b>:
            </solution>
            <b>Alternatives</b>:
            
            <h3 id="Waste-Service-Transport-Trolley">Waste Service &harr; Transport Trolley</h3>
            
            <h3 id="Transport-Trolley-DDR-Robot">Transport Trolley &harr; DDR Robot</h3>
            
            <h2 id="Logical-Architecture">Logical Architecture</h2>
            <img width="100%" src="../../Sprint1_ProblemAnalysis/waste_servicearch.png"/>
            QAK model: <a href="../../Sprint1_ProblemAnalysis/src/waste_service.qak">waste_service.qak</a>
            
            <h2 id="Test-Plans">Test Plans</h2>
            <table class="dictionary">
                <tr>
                    <th>Test</th>
                    <th>Involved Actors</th>
                    <th>Description</th>
                    <th>Files</th>
                </tr>
                <tr>
                    <td>Receive the correct WasteTypes List</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>TypesProvider</li>
                        </ul>
                    </td>
                    <td>We check if the TypesProvider actor replies correctly to the SmartDevice, with the list of WasteTypes available.</td>
                    <td>
                        QAK: <a href="../../Sprint1_ProblemAnalysis/src/test_types_provider.qak">test_types_provider.qak</a>
                        Test: <a href="../../Sprint1_ProblemAnalysis/test/it/unibo/wasteservice/TestTypesProvider.kt">TestTypesProvider.kt</a>
                    </td>
                    <!-- NB: to test the TypesProvider we can just use a TCP connection and analyze the reply content,
                        we don't need COAP, since it's a simple task to verify -->
                </tr>
                <tr>
                    <td>StoreRequest Handling: loadaccepted</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>WasteService</li>
                            <li>TransportTrolley</li>
                        </ul>
                    </td>
                    <td>
                        We send a StoreRequest for a load that can be stored for sure, and we check if the SmartDevice receives a
                        loadaccepted message from the WasteService, after the pickup action is completed.
                    </td>
                    <td rowspan="5">
                        QAK: <a href="../../Sprint1_ProblemAnalysis/src/test_waste_service.qak">test_waste_service.qak</a>
                        Test: <a href="../../Sprint1_ProblemAnalysis/test/it/unibo/wasteservice/TestWasteService.kt">TestWasteService.kt</a>
                        <highlight1>Report</highlight1>
                    </td>
                </tr>
                <tr>
                    <td>StoreRequest Handling: storage update</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>WasteService</li>
                        </ul>
                    </td>
                    <td>We check if the WasteService correctly updates the storage counter by sending 2 StoreRequest sequentially:
                        <ol>
                            <li>The first contains the maximum load a certain container can store.</li>
                            <li>The second contains any value (we don't care, since the storage must be already full).</li>
                        </ol>
                        Then we check if we received a loadaccepted for the first and a loadrejected for the second.
                    </td>
                </tr>
                <tr>
                    <td>StoreRequest Handling: loadrejected (invalid WasteType)</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>WasteService</li>
                        </ul>
                    </td>
                    <td>We check if the StoreRequest gets rejected when the WasteType is invalid (e.g. "ORGANIC").</td>
                </tr>
                <tr>
                    <td>StoreRequest Handling: loadrejected (invalid WasteWeight)</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>WasteService</li>
                        </ul>
                    </td>
                    <td>We check if the StoreRequest gets rejected when the WasteWeight is invalid (e.g. negative value).</td>
                </tr>
                <tr>
                    <td>StoreRequest Handling: loadrejected (not enough space)</td>
                    <td>
                        <ul>
                            <li>SmartDevice</li>
                            <li>WasteService</li>
                        </ul>
                    </td>
                    <td>We check if the StoreRequest gets rejected when the container of the given WasteType is full.</td>
                </tr>
                <tr>
                    <td>Deposit Handling:
                        GLASS
                    </td>
                    <td>
                        <ul>
                            <li>WasteService</li>
                            <li>TransportTrolley</li>
                        </ul>
                    </td>
                    <td>We check if the TransportTrolley transits through all the states necessary for the execution of the GLASS deposit action..</td>
                    <td rowspan="5">
                        QAK: <a href="../../Sprint1_ProblemAnalysis/src/test_transport_trolley.qak">test_transport_trolley.qak</a>
                        Test: <a href="../../Sprint1_ProblemAnalysis/test/it/unibo/wasteservice/TestTransportTrolley.kt">TestTransportTrolley.kt</a>
                    </td>
                </tr>
                <tr>
                    <td>Deposit Handling:
                        PLASTIC
                    </td>
                    <td>
                        <ul>
                            <li>WasteService</li>
                            <li>TransportTrolley</li>
                        </ul>
                    </td>
                    <td>We check if the TransportTrolley transits through all the states necessary for the execution of the PLASTIC deposit action.</td>
                </tr>
            </table>
            <highlight1>How to run the tests</highlight1>
        </div>

    </body>

</html>
