// PROJECT - TEST PLAN
System test_waste_service

// MESSAGES AND EVENTS ========================================================
// SmartDevice (truck) -> WasteService
Request wastetypes_request	:	wastetypes_request(_)
Reply wastetypes_reply		:	wastetypes_reply(TYPES)
Request storerequest	:	storerequest(TYPE, LOAD)

// WasteService -> SmartDevice
Reply loadaccepted	:		loadaccepted(_)
Reply loadrejected	:		loadrejected(_)

// WasteService -> TransportTrolley
Request deposit		:		deposit(TYPE)

// TransportTrolley -> WasteService
Reply depositcompleted	:	depositcompleted(_)
Reply depositfailed		:	depositfailed(REASON)

// Basicrobot
Dispatch cmd : cmd(MOVE)
Dispatch end       	: end(ARG)  
Request step : step(TIME)
Reply stepdone : stepdone(V)
Reply stepfail : stepfail(V)
Event alarm : alarm(X)
Event  sonar       : sonar( DISTANCE )
Dispatch obstacle  : obstacle( ARG ) 	//generated by distancefilter
Event   info       : info( ARG ) 	    //for external components, not coap-observed


// PathExecutor
Request	dopath		: dopath( PATH, OWNER )
Reply	dopathdone	: dopathdone( ARG )
Reply	dopathfail	: dopathfail( ARG )
Dispatch pathdone	: pathdone( P )
Dispatch pathfail	: pathdone( P )
Dispatch cmd		: cmd(MOVE)     
Request step		: step( TIME )	
Reply   stepdone	: stepdone(V)  
Reply   stepfail	: stepfail(DURATION, CAUSE)
Event	alarm		: alarm(X) 

Context ctx_wasteservice_test	ip [host="localhost" port=11800]

QActor smartdevice_simulator context ctx_wasteservice_test {
	[#
		var Types: String = ""
		var TypesList = arrayListOf<wasteservice.WasteType>()
		
		var WasteType: wasteservice.WasteType = wasteservice.WasteType.PLASTIC
		var WasteWeight: Double = 10.0
	#]
	State state_init initial {
		println("[SmartDevice Simulator] Started")
		discardMsg Off
		
		delay 5000
		
		request wasteservice -m storerequest : storerequest($WasteType, $WasteWeight)
		println("[SmartDevice Simulator] Sent storerequest($WasteType, $WasteWeight)")
	}
	Transition t2	whenReply	loadaccepted -> state_handle_loadaccepted
					whenReply	loadrejected -> state_handle_loadrejected
	
	State state_handle_loadaccepted {
		println("[SmartDevice Simulator] Received LoadAccepted")
	}
	
	State state_handle_loadrejected {
		println("[SmartDevice Simulator] Received LoadRejected")
	}
}

QActor wasteservice context ctx_wasteservice_test {
	[#
		var Type = ""
	#]
	State state_init initial {
		println("[WasteService] Started")
	}
	Goto state_idle
	
	State state_idle {
		println("[WasteService] Waiting for store requests...")
		discardMsg Off
	}
	Transition t1	whenRequest storerequest	-> state_handle_storerequest

	State state_handle_storerequest {
		printCurrentMessage
		onMsg(storerequest: storerequest(TYPE, LOAD)) {
			[#
				var TYPE = payloadArg(0)
				var LOAD = payloadArg(1)	
			#]
			println("[WasteService] Received storerequest($TYPE, $LOAD)")
			//[# Type = $TYPE #]
			request transporttrolley -m deposit : deposit( payloadArg(0) ) // $Type )
			
			replyTo storerequest with loadaccepted: loadaccepted(_)
			println("[WasteService] Replied with loadaccepted")	
			//forward basicrobot -m cmd : cmd(w)
			//println("Sent BasicRobot: -> cmd(w)")
			//println("Sent PathExecutor: -> dopath()")
		}
	}
	// when reply?
	Goto state_idle
}

QActor transporttrolley context ctx_wasteservice_test {
	[# 
		var Actions: String = "" 
		var Progress = ""
		planner.initAI()
		planner.loadRoomMap("mapRoomEmpty")
	#]
	State state_init initial {
		println("[TransportTrolley] Started")
		//forward basicrobot -m cmd : cmd(w) // test OK
		
	}
	Goto state_idle
	
	State state_idle {
		println("[TransportTrolley] Waiting for deposit actions...")
	}
	Transition t1	whenRequest deposit		-> state_handle_deposit_request
	
	State state_handle_deposit_request {
		printCurrentMessage
		onMsg(deposit: deposit(_)) {
			println("[TransportTrolley] Received deposit request...")
			
			[#
				planner.setGoal(4, 3)
				planner.doPlan()
				Actions = planner.getActionsString()
			#]
			request pathexecutor -m dopath : dopath($Actions, transporttrolley)
			
			replyTo deposit with depositcompleted: depositcompleted(_)
		}
		
	}
	Transition t1 whenReply dopathdone -> state_path_done
				  whenReply dopathfail -> state_path_fail
	
	
	State state_path_done {
		
	}
	Goto state_idle
	
	State state_path_fail {
		
	}
	Goto state_idle
}

QActor pathexecutor context ctx_wasteservice_test {
	[# 
		var CurMoveTodo = ""
		var MovesDone = "" 
	#]
	
	State init initial {
		[# CurMoveTodo = "" #]
		[# sysUtil.logMsgs=true #]
		println("[PathExecutor] started")
	}
	Transition t0 whenRequest dopath -> doThePath
	
	State doThePath {
		printCurrentMessage
		onMsg(dopath : dopath(P, C)) {
			[# val path = payloadArg(0); println(path) #]
			[# pathut.setPath(path) #]
		}
		
		println("[PathExecutor] pathTodo: ${pathut.getPathTodo()}")
	}
	Goto nextMove
	
	State nextMove {
		[# CurMoveTodo = pathut.nextMove() #]
		[# MovesDone += CurMoveTodo #]
		println("[PathExecutor] curMoveTodo: $CurMoveTodo")
	}
	Goto endWorkOk if [# CurMoveTodo.length == 0 #] else doMove
	
	State doMove {
		[#
			planner.updateMap(CurMoveTodo, "")
			// planner.showMap()
			// planner.showCurrentRobotState()	
		#]
		delay 350
	}
	Goto doMoveW if [# CurMoveTodo == "w" #] else doMoveTurn
	
	State doMoveTurn {
		forward basicrobot -m cmd : cmd($CurMoveTodo)
	}
	Transition t1 whenTime 350 -> nextMove
			
	State doMoveW {
		request basicrobot -m step : step(350)
	}
	Transition t2 whenEvent alarm -> handleAlarm
				  whenReply stepdone -> nextMove
				  whenReply stepfail -> endWorkKo
				  
	State handleAlarm {
		[# var PathTodo = pathut.getPathTodo() #]
		println("[PathExecutor] handleAlarm ... pathTodo: $PathTodo")
	}
	
	State endWorkOk {
		println("[PathExecutor] Path done - bye")
		replyTo dopath with dopathdone : dopathdone( ok )
	}
	Goto init
	
	State endWorkKo {
		[# var PathStillTodo = pathut.getPathTodo() #]
		println("[PathExecutor] path failure - sorry. PathStillTodo: $PathStillTodo")
		replyTo dopath with dopathfail : dopathfail( $PathStillTodo )
	}
	Transition t0 whenEvent alarm -> handleAlarm
}

QActor basicrobot context ctx_wasteservice_test {
[#
  var StepTime      = 0L
  var StartTime     = 0L     
  var Duration      = 0L  
  var RobotType     = "" 
  var CurrentMove   = "unkknown"
#]  
 	State s0 initial { 	      
 		discardMsg Off  //WE want receive any msg
 		//[# unibo.comm22.utils.CommSystemConfig.tracing = false #]  //tracing at unibo.comm22 level
		println("basicrobot | START")	
 		qrun unibo.robot.robotSupport.create(myself,"basicrobotConfig.json")	
 		[# RobotType = unibo.robot.robotSupport.robotKind #]
 		delay 1000  //give to the realsonar the time to start
        if[# RobotType != "virtual" #]{
        	[# var robotsonar = context!!.hasActor("realsonar")  
        	   if(robotsonar != null) unibo.robot.robotSupport.createSonarPipe(robotsonar) 
        	#] 
  		}//The Virtual robot sonar is created in virtualrobotSupport2021
 
  		//run unibo.robot.robotSupport.move( "a" )    //synch
 		//run unibo.robot.robotSupport.move( "d" )	//synch
    		//run unibo.robot.robotSupport.move( "w" )    //asynch
 		updateResource [# "basicrobot(start)" #]
 	} 
	Goto work
	
	State work{ 
		println("basicrobot  | waiting .................. ")  
	} 
	Transition t1   whenMsg     cmd       -> execcmd
					whenRequest step      -> doStep			 
					whenMsg    obstacle   -> handleObstacle  //in virtualrobot caused by the move w/s
					//whenEvent sonar       -> handleSonar
				  	whenMsg     end       -> endwork			  
	
	State execcmd{
		printCurrentMessage
		onMsg( cmd : cmd(MOVE) ){
  			//activate the motors  
  			[# CurrentMove = payloadArg(0) #]
			run unibo.robot.robotSupport.move( payloadArg(0 ) )
			updateResource [# "moveactivated(${payloadArg(0)})" #]
		}
	 }
	 Goto work   
	 
	State handleObstacle{
		//println("basicrobotttttttttt | handleObstacle ${CurrentMove}")	
		//run unibo.robot.robotSupport.move( "h" ) //non importa 
		//printCurrentMessage
		updateResource [# "obstacle(${CurrentMove})" #]
		//JUNE22: behavior embedded in VirtualrobotSupport2021
		/* 
		if[# CurrentMove == "w" #]{
		//back to avoid emission of obstacle again if real robot moving forward !!!
		//if[# RobotType != "virtual" #]{	
			run unibo.robot.robotSupport.move( "s" )
			delay 100 
			run unibo.robot.robotSupport.move( "h" ) 
 		}*/
 		//emit info : info( obstacledoing(w) )
	}
	Goto work  
 
	State handleSonar{
		printCurrentMessage
	}
	Goto work
		
   	State doStep{ 
 		printCurrentMessage  
		onMsg( step : step( T ) ){  
			[#	StepTime = payloadArg(0).toLong() 	#]  
			updateResource [# "step(${StepTime})" #]
  		}  
        memoCurrentTime StartTime  
        println("basicrobot | doStep StepTime =$StepTime  ")        
        run unibo.robot.robotSupport.move( "w" )  //moves a real robot forever !!!
	}  
	Transition t0 
		whenTimeVar StepTime  -> stepDone  	 
 		whenMsg  obstacle     -> stepFail		
    	 
	
	State stepDone{   
 		run unibo.robot.robotSupport.move( "h" )  //stop the real robot already done ???
		updateResource [# "stepDone($StepTime)" #]
   		//emit info : info( stepdone($StepTime) )
   		replyTo step with stepdone : stepdone(ok)
		println("basicrobot | stepDone reply done")
  	}
	Goto work  
 
	State stepFail{  	 	
		setDuration Duration from StartTime
		run unibo.robot.robotSupport.move( "h" )  //stop the (real) robot
		//[# var TunedDuration =  Duration * 5 / 6 #]
		//[# var TunedDuration   = kotlin.math.round( (StepTime - Duration) * 15 / 100 ) #]
		[# var TunedDuration   =  ((StepTime - Duration) * 15 / 100).toLong()   #]
		println("basicrobot | stepFail duration=$Duration TunedDuration=$TunedDuration")
			run unibo.robot.robotSupport.move( "s" )
			delayVar TunedDuration 
			run unibo.robot.robotSupport.move( "h" ) 
 		updateResource [# "stepFail($Duration)" #] 
 		//emit info : info( stepFail($Duration) )
 		replyTo step with stepfail : stepfail($Duration, obst)
    }
	Goto work
	
	State endwork{ 
		updateResource [# "basicrobot(end)" #]	 		
 		terminate 1
	}   
 
}